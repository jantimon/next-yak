{"version":3,"sources":["../../loaders/lib/stripCssComments.ts","../../loaders/lib/quasiClassifier.ts","../../loaders/lib/replaceQuasiExpressionTokens.ts","../../loaders/lib/hash.ts","../../loaders/lib/localIdent.ts","../../loaders/lib/getStyledComponentName.ts","../../loaders/lib/appendCssUnitToExpressionValue.ts","../../loaders/lib/getCssName.ts","../../loaders/lib/getConstantValues.ts","../../loaders/babel-yak-plugin.ts","../../loaders/tsloader.ts","../../loaders/lib/getYakImports.ts"],"sourcesContent":["// from https://github.com/sindresorhus/strip-css-comments/tree/main\nexport default function stripCssComments(cssString: string) {\n  let isInsideString: string | false = false;\n  let currentCharacter = \"\";\n  let comment = \"\";\n  let returnValue = \"\";\n\n  for (let index = 0; index < cssString.length; index++) {\n    currentCharacter = cssString[index];\n\n    if (\n      cssString[index - 1] !== \"\\\\\" &&\n      (currentCharacter === '\"' || currentCharacter === \"'\")\n    ) {\n      if (isInsideString === currentCharacter) {\n        isInsideString = false;\n      } else if (!isInsideString) {\n        isInsideString = currentCharacter;\n      }\n    }\n\n    // Find beginning of `/*` type comment\n    if (\n      !isInsideString &&\n      currentCharacter === \"/\" &&\n      cssString[index + 1] === \"*\"\n    ) {\n      let index2 = index + 2;\n\n      // Iterate over comment\n      for (; index2 < cssString.length; index2++) {\n        // Find end of comment\n        if (cssString[index2] === \"*\" && cssString[index2 + 1] === \"/\") {\n          if (cssString[index2 + 2] === \"\\n\") {\n            index2++;\n          } else if (cssString[index2 + 2] + cssString[index2 + 3] === \"\\r\\n\") {\n            index2 += 2;\n          }\n          comment = \"\";\n          break;\n        }\n        // Store comment text\n        comment += cssString[index2];\n      }\n      // Resume iteration over CSS string from the end of the comment\n      index = index2 + 1;\n      continue;\n    }\n    returnValue += currentCharacter;\n  }\n  return returnValue;\n}\n","import stripCssComments from \"./stripCssComments.js\";\n\n/**\n * Checks a quasiValue and returns its type\n *\n * - empty: no expressions, no text\n * - unknownSelector: starts with a `{` e.g. `{ opacity: 0.5; }` or `,` e.g. `, bar { ... }`\n * - insideCssValue: does not end with a `{` or `}` or `;` e.g. `color: `\n */\nexport default function quasiClassifier(\n  quasiValue: string,\n  currentNestingScopes: string[]\n) {\n  // TODO - for better performance we could move the comment skipping logic\n  // directly in the for loop below instead of calling stripCssComments\n  const trimmedCssString = stripCssComments(quasiValue).trim();\n  if (trimmedCssString === \"\") {\n    return {\n      empty: true,\n      unknownSelector: false,\n      insideCssValue: false,\n      currentNestingScopes,\n    };\n  }\n  let isInsideString: '\"' | \"'\" | false = false;\n  let currentCharacter = \"\";\n  let newNestingLevel = [...currentNestingScopes];\n  let currentSelector = \"\";\n  for (let index = 0; index < trimmedCssString.length; index++) {\n    currentCharacter = trimmedCssString[index];\n    if (\n      trimmedCssString[index - 1] !== \"\\\\\" &&\n      (currentCharacter === '\"' || currentCharacter === \"'\")\n    ) {\n      if (isInsideString === currentCharacter) {\n        isInsideString = false;\n      } else if (!isInsideString) {\n        isInsideString = currentCharacter;\n      }\n    }\n    if (isInsideString) {\n      continue;\n    }\n    if (currentCharacter === \"{\") {\n      const selector = currentSelector.trim();\n      if (selector !== \"\") {\n        newNestingLevel.push(selector);\n      }\n      // after an opening bracket a new selector might start e.g.:\n      // .class {\n      //   .nested-class {\n      currentSelector = \"\";\n    } else if (currentCharacter === \"}\") {\n      newNestingLevel.pop();\n      // after a closing bracket a new selector might start e.g.:\n      // .class {\n      //   color: red;\n      // }\n      // .other-class {\n      currentSelector = \"\";\n    } else if (currentCharacter === \";\") {\n      // after a semi-colon a nested selector might start e.g.:\n      // .class {\n      //   color: red;\n      //   .nested-class {\n      currentSelector = \"\";\n    } else {\n      currentSelector += currentCharacter;\n    }\n  }\n\n  return {\n    empty: false,\n    unknownSelector: trimmedCssString[0] === \"{\" || trimmedCssString[0] === \",\",\n    insideCssValue:\n      currentCharacter !== \"{\" &&\n      currentCharacter !== \"}\" &&\n      currentCharacter !== \";\",\n    currentNestingScopes: newNestingLevel,\n  };\n}\n","import type { NodePath, types as babelTypes } from \"@babel/core\";\n\n/**\n * Replace tokens with predefined values e.g.\n *\n * ```js\n *  css`\n *    color: red;\n *    ${query.xs} {\n *      color: blue;\n *   }\n * `\n *\n * ```\n * becomes\n * ```js\n * css`\n *  color: red;\n *  @media (min-width: 0px) {\n *    color: blue;\n * }\n * `\n * ```\n */\nexport default function replaceTokensInQuasiExpressions(\n  quasi: babelTypes.TemplateLiteral,\n  replacer: (name: string) => unknown,\n  t: typeof babelTypes\n) {\n  // Iterate over the expressions in reverse order\n  // so removing items won't affect the index of the next item\n  for (let i = quasi.expressions.length - 1; i >= 0; i--) {\n    const expression = quasi.expressions[i];\n    // break the expression into parts\n    // e.g. x.y.z -> [\"x\", \"y\", \"z\"]\n    const parts = getExpressionParts(expression, t);\n    // find the replacement for the expression\n    const replacement = parts && replacer(parts[0]);\n    // if it is a nested value, find the value of the expression\n    // e.g. x.y.z -> find the value of z\n    const replacementValue =\n      replacement && getReplacementValue(replacement, parts);\n    if (replacementValue !== false && replacementValue !== null) {\n      replaceExpressionAndMergeQuasis(quasi, i, replacementValue);\n    }\n  }\n}\n\n/**\n * Replace tokens with predefined values\n */\nfunction replaceExpressionAndMergeQuasis(\n  quasi: babelTypes.TemplateLiteral,\n  expressionIndex: number,\n  replacement: unknown\n) {\n  const stringReplacement =\n    typeof replacement === \"string\"\n      ? replacement\n      : replacement == null\n      ? \"\"\n      : JSON.stringify(replacement);\n  quasi.expressions.splice(expressionIndex, 1);\n  quasi.quasis[expressionIndex].value.raw +=\n    stringReplacement + quasi.quasis[expressionIndex + 1].value.raw;\n  quasi.quasis[expressionIndex].value.cooked +=\n    stringReplacement + quasi.quasis[expressionIndex + 1].value.cooked;\n  quasi.quasis.splice(expressionIndex + 1, 1);\n}\n\n/**\n * Find the replacement for the expression\n *\n * searches for:\n *   - `x` -> [\"x\"]\n *   - `x.y` -> [\"x\", \"y\"]\n *   - `x[0]` -> [\"x\", 0]\n *   - `x()` -> [\"x\"]\n *   - `x.y()` -> [\"x\", \"y\"]\n *   - (1 + 2) -> null\n */\nfunction getExpressionParts(\n  expression: babelTypes.Expression | babelTypes.TSType,\n  t: typeof babelTypes\n) {\n  let currentExpression = expression;\n  /** @type {string[]} */\n  const tokens = [];\n  while (currentExpression) {\n    // e.g. x\n    if (t.isIdentifier(currentExpression)) {\n      tokens.unshift(currentExpression.name);\n      break;\n    }\n    // e.g. x.y\n    if (t.isMemberExpression(currentExpression)) {\n      if (\n        currentExpression.computed === false &&\n        t.isIdentifier(currentExpression.property)\n      ) {\n        tokens.unshift(currentExpression.property.name);\n      } else if (t.isStringLiteral(currentExpression.property)) {\n        tokens.unshift(currentExpression.property.value);\n      } else if (t.isNumericLiteral(currentExpression.property)) {\n        tokens.unshift(String(currentExpression.property.value));\n      } else {\n        return null;\n      }\n      currentExpression = currentExpression.object;\n    } else if (t.isCallExpression(currentExpression)) {\n      if (!t.isExpression(currentExpression.callee)) {\n        return null;\n      }\n      currentExpression = currentExpression.callee;\n    } else {\n      return null;\n    }\n  }\n  return tokens;\n}\n\n/**\n * Get the value of the replacement\n *\n * e.g. for `replacement.x.y[0]` and `replacement = { x: { y: [42] } }`\n * parts = [\"replacement\", \"x\", \"y\", 0]\n * --> 42\n */\nfunction getReplacementValue(replacement: any, parts: string[]) {\n  let currentReplacement = replacement;\n  for (let i = 1; i < parts.length; i++) {\n    const part = parts[i];\n    if (currentReplacement == null || typeof currentReplacement !== \"object\") {\n      return false;\n    }\n    currentReplacement = currentReplacement[part];\n  }\n  return currentReplacement;\n}\n","/**\n * JS Implementation of MurmurHash2\n *\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n *\n * @param str ASCII only\n * @return Base 36 encoded hash result\n */\nexport default function murmurhash2_32_gc(str: string) {\n  let l = str.length;\n  let h = l;\n  let i = 0;\n  let k;\n\n  while (l >= 4) {\n    k =\n      (str.charCodeAt(i) & 0xff) |\n      ((str.charCodeAt(++i) & 0xff) << 8) |\n      ((str.charCodeAt(++i) & 0xff) << 16) |\n      ((str.charCodeAt(++i) & 0xff) << 24);\n\n    k =\n      (k & 0xffff) * 0x5bd1e995 + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16);\n    k ^= k >>> 24;\n    k =\n      (k & 0xffff) * 0x5bd1e995 + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16);\n\n    h =\n      ((h & 0xffff) * 0x5bd1e995 +\n        ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^\n      k;\n\n    l -= 4;\n    ++i;\n  } // forgive existing code\n\n  /* eslint-disable no-fallthrough */ switch (l) {\n    case 3:\n      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n    case 2:\n      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n    case 1:\n      h ^= str.charCodeAt(i) & 0xff;\n      h =\n        (h & 0xffff) * 0x5bd1e995 +\n        ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16);\n  }\n  /* eslint-enable no-fallthrough */\n\n  h ^= h >>> 13;\n  h = (h & 0xffff) * 0x5bd1e995 + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16);\n  h ^= h >>> 15;\n\n  return (h >>> 0).toString(36);\n}\n","/**\n * Generates local names used in the generated CSS.\n * It is also used in the js code to reference the generated CSS.\n *\n * E.g.:\n * ```ts\n * localIdent(\"myVariableName\", 1, \"selector\") // \".myVariableName_1\"\n * localIdent(\"myVariableName\", 1, \"className\") // \"myVariableName_1\"\n * localIdent(\"myVariableName\", 1, \"keyframes\") // \"@keyframes myVariableName_1\"\n * localIdent(\"myVariableName\", 1, \"animation\") // \"myVariableName_1\"\n * ```\n */\nexport default function localIdent(\n  variableName: string,\n  i: number | null,\n  kind: \"selector\" | \"className\" | \"keyframes\" | \"animation\"\n) {\n  switch (kind) {\n    case \"selector\":\n      return `.${variableName}${i === null ? \"\" : `_${i}`}`;\n    case \"className\":\n    case \"animation\":\n      return `${variableName}${i === null ? \"\" : `_${i}`}`;\n    case \"keyframes\":\n      return `@keyframes ${variableName}${i === null ? \"\" : `_${i}`}`;\n    default:\n      throw new Error(\"unknown kind\");\n  }\n}\n","import type { NodePath, types as babelTypes } from \"@babel/core\";\n\n/**\n * Try to get the name of a styled component from a call or member expression\n *\n * e.g. const MyButton = styled.div`...` -> \"MyButton\"\n * e.g. const FancyButton = styled(MyButton)`...` -> \"FancyButton\"\n */\nconst getStyledComponentName = (\n  taggedTemplateExpressionPath: NodePath<babelTypes.TaggedTemplateExpression>\n) => {\n  const variableDeclaratorPath = taggedTemplateExpressionPath.findParent(\n    (path) => path.isVariableDeclarator()\n  );\n  if (\n    !variableDeclaratorPath ||\n    !(\"id\" in variableDeclaratorPath.node) ||\n    variableDeclaratorPath.node.id?.type !== \"Identifier\"\n  ) {\n    throw new Error(\n      \"Could not find variable declaration for styled component at \" +\n        taggedTemplateExpressionPath.node.loc\n    );\n  }\n  return variableDeclaratorPath.node.id.name;\n};\n\nexport default getStyledComponentName;\n","import type { types as babelTypes } from \"@babel/core\";\n\n/**\n * Extracts the css unit from a css string and checks if it is a valid CSS unit\n */\nconst appendCssUnitToExpressionValue = (\n  cssUnit: string,\n  expression: babelTypes.Expression,\n  runtimeInternalHelpers: Set<string>,\n  t: typeof babelTypes\n) => {\n  if (expression.type === \"ArrowFunctionExpression\") {\n    if (expression.body.type !== \"BlockStatement\") {\n      const newBody = t.binaryExpression(\n        \"+\",\n        t.parenthesizedExpression(expression.body),\n        t.stringLiteral(cssUnit)\n      );\n\n      const newArrowFunction = t.arrowFunctionExpression(\n        expression.params,\n        newBody\n      );\n      return newArrowFunction;\n    }\n  } else if (\n    expression.type === \"NumericLiteral\" ||\n    expression.type === \"BinaryExpression\" ||\n    expression.type === \"Identifier\"\n  ) {\n    const cssUnitLiteral = t.stringLiteral(cssUnit);\n    const binaryExpression = t.binaryExpression(\n      \"+\",\n      expression,\n      cssUnitLiteral\n    );\n    return binaryExpression;\n  }\n\n  const callExpression = t.callExpression(t.identifier(\"__yak_unitPostFix\"), [\n    expression,\n    t.stringLiteral(cssUnit),\n  ]);\n  runtimeInternalHelpers.add(\"__yak_unitPostFix\");\n  return callExpression;\n};\n\nexport default appendCssUnitToExpressionValue;\n","import type { NodePath, types as babelTypes } from \"@babel/core\";\n\n/**\n * Extracts the conditions from a path\n */\nfunction extractConditions(\n  path: NodePath<babelTypes.TaggedTemplateExpression>\n) {\n  const conditions: string[] = [];\n  const visitedNodes = new Set();\n  const getConditions = (\n    node: babelTypes.Node,\n    previousNode: babelTypes.Node,\n    isNegated = false\n  ) => {\n    if (visitedNodes.has(node)) return;\n    visitedNodes.add(node);\n    // Support for && and || operators e.g. disabled && \"disabled\"\n    if (node.type === \"LogicalExpression\") {\n      if (node.operator === \"&&\") {\n        getConditions(node.right, previousNode, isNegated);\n        conditions.push(\"and\");\n        getConditions(node.left, previousNode, isNegated);\n      } else if (node.operator === \"||\") {\n        getConditions(node.right, previousNode, isNegated);\n        conditions.push(\"or\");\n        getConditions(node.left, previousNode, isNegated);\n      }\n    }\n    // Support for ternary operator e.g. disabled ? \"disabled\" : \"enabled\"\n    else if (node.type === \"ConditionalExpression\") {\n      conditions.push(\"and\");\n      getConditions(node.test, previousNode, node.alternate === previousNode);\n    }\n    // Support for ! operator e.g. !disabled\n    else if (node.type === \"UnaryExpression\" && node.operator === \"!\") {\n      getConditions(node.argument, previousNode, !isNegated);\n    }\n    // Support for Boolean() function e.g. Boolean(disabled)\n    else if (\n      node.type === \"CallExpression\" &&\n      node.callee.type === \"Identifier\" &&\n      node.callee.name === \"Boolean\"\n    ) {\n      getConditions(node.arguments[0], previousNode, isNegated);\n    }\n    // Get the name of the variable e.g. disabled\n    else if (node.type === \"Identifier\") {\n      conditions.push((isNegated ? \"not_\" : \"\") + node.name);\n    }\n    // Get the name of a member expression e.g. props.disabled\n    else if (node.type === \"MemberExpression\") {\n      conditions.push(\n        (isNegated ? \"not_\" : \"\") + getMemberExpressionName(node)\n      );\n    }\n  };\n  let currentPath: NodePath | null = path;\n  let previousPath: NodePath = path;\n  while (currentPath) {\n    getConditions(currentPath.node, previousPath.node);\n    previousPath = currentPath;\n    currentPath = currentPath.parentPath;\n  }\n  if (conditions[0] === \"or\" || conditions[0] === \"and\") {\n    conditions.shift();\n  }\n  return conditions.reverse();\n}\n\n/**\n * Try to get the name of a css component from a literal expression\n *\n * e.g. const mixin = css`...` -> \"mixin\"\n */\nconst getStyledComponentName = (\n  taggedTemplateExpressionPath: NodePath<babelTypes.TaggedTemplateExpression>\n) => {\n  const variableDeclaratorPath = taggedTemplateExpressionPath.findParent(\n    (path) => path.isVariableDeclarator()\n  );\n  if (\n    !variableDeclaratorPath ||\n    !(\"id\" in variableDeclaratorPath.node) ||\n    variableDeclaratorPath.node.id?.type !== \"Identifier\"\n  ) {\n    return null;\n  }\n  return variableDeclaratorPath.node.id.name;\n};\n\n/**\n * Try to get the name of a member expression\n *\n * e.g. props.disabled -> \"propsDisabled\"\n * e.g. props.user.disabled -> \"propsUserDisabled\n */\nfunction getMemberExpressionName(node: babelTypes.MemberExpression): string {\n  if (\n    !node.object ||\n    !node.property ||\n    (node.object.type !== \"Identifier\" &&\n      node.object.type !== \"MemberExpression\")\n  ) {\n    return \"\";\n  }\n  const objectName =\n    node.object.type === \"Identifier\"\n      ? node.object.name\n      : getMemberExpressionName(node.object);\n  const property = node.property;\n  let propertyName = \"\";\n  if (property.type === \"Identifier\") {\n    propertyName = property.name;\n  } else if (property.type === \"StringLiteral\") {\n    propertyName = property.value;\n  }\n  if (!propertyName) {\n    return \"\";\n  }\n  return objectName + propertyName[0].toUpperCase() + propertyName.slice(1);\n}\n\n/**\n * Try to get the name of a css literal\n *\n * e.g. ({$disabled}) => $disabled && css`...` -> \"is_$disabled\"\n */\nexport default function getCssName(\n  literal: NodePath<babelTypes.TaggedTemplateExpression>\n) {\n  const conditions = extractConditions(literal);\n  if (conditions.length === 0) {\n    const mixinName = getStyledComponentName(literal);\n    return mixinName ? mixinName : \"yak\";\n  }\n  return conditions.join(\"_\").replace(/\\$/g, \"\");\n}\n","import type { NodePath, types as babelTypes } from \"@babel/core\";\n\n/**\n * Returns the name of the expression\n */\nexport const getConstantName = (\n  expression: babelTypes.Expression,\n  t: typeof babelTypes\n) => {\n  // e.g. styled.div`color: ${x};`\n  if (t.isIdentifier(expression)) {\n    // e.g. x\n    return expression.name;\n  } else if (\n    t.isMemberExpression(expression) &&\n    t.isIdentifier(expression.object)\n  ) {\n    // e.g. x for x.y\n    return expression.object.name;\n  } else if (\n    t.isCallExpression(expression) &&\n    t.isIdentifier(expression.callee)\n  ) {\n    // e.g. x for x()\n    return expression.callee.name;\n  } else if (\n    t.isCallExpression(expression) &&\n    t.isMemberExpression(expression.callee) &&\n    t.isIdentifier(expression.callee.object)\n  ) {\n    // e.g. x for x.y()\n    return expression.callee.object.name;\n  } else {\n    return null;\n  }\n};\n\n/**\n * Extracts all top level constant values from a program path\n */\nexport function getConstantValues(\n  path: NodePath<babelTypes.Program>,\n  t: typeof babelTypes\n) {\n  const topLevelConstBindings = new Map<string, string | number | null>();\n  const bindings = Object.entries(path.scope.bindings);\n  for (const [name, binding] of bindings) {\n    if (binding.kind === \"module\") {\n      topLevelConstBindings.set(name, null);\n      continue;\n    }\n    if (\n      binding.kind === \"let\" ||\n      binding.kind === \"var\" ||\n      binding.kind === \"const\"\n    ) {\n      // don't consider function declarations or arrow functions as constants\n      if (\n        !(\"init\" in binding.path.node) ||\n        t.isFunctionDeclaration(binding.path.node.init) ||\n        t.isArrowFunctionExpression(binding.path.node.init)\n      ) {\n        topLevelConstBindings.set(name, null);\n        continue;\n      }\n      const value = binding.path.node.init;\n      topLevelConstBindings.set(\n        name,\n        t.isStringLiteral(value) || t.isNumericLiteral(value)\n          ? value.value\n          : null\n      );\n    }\n  }\n  return topLevelConstBindings;\n}\n","import type babelCore from \"@babel/core\";\nimport {\n  BabelFile,\n  NodePath,\n  PluginObj,\n  PluginPass,\n  types as babelTypes,\n} from \"@babel/core\";\nimport quasiClassifier from \"./lib/quasiClassifier.js\";\nimport replaceQuasiExpressionTokens from \"./lib/replaceQuasiExpressionTokens.js\";\nimport murmurhash2_32_gc from \"./lib/hash.js\";\nimport { relative, resolve, basename } from \"node:path\";\nimport localIdent from \"./lib/localIdent.js\";\nimport getStyledComponentName from \"./lib/getStyledComponentName.js\";\nimport appendCssUnitToExpressionValue from \"./lib/appendCssUnitToExpressionValue.js\";\nimport getCssName from \"./lib/getCssName.js\";\nimport { getConstantName, getConstantValues } from \"./lib/getConstantValues.js\";\n\ntype YakBabelPluginOptions = {\n  replaces: Record<string, unknown>;\n  rootContext?: string;\n};\n\ntype YakLocalIdentifierNames = {\n  css: string | undefined;\n  styled: string | undefined;\n  keyframes: string | undefined;\n};\n\n/**\n * Babel plugin for typescript files that use yak - it will do things:\n * - inject the import to the css-module (with .yak.module.css extension)\n * - replace the css template literal with styles from the css-module\n */\nexport default function (\n  babel: typeof babelCore,\n  options: YakBabelPluginOptions\n): PluginObj<\n  PluginPass & {\n    localVarNames: YakLocalIdentifierNames;\n    isImportedInCurrentFile: boolean;\n    classNameCount: number;\n    topLevelConstBindings: Map<string, number | string | null>;\n    varIndex: number;\n    variableNameToStyledCall: Map<\n      string,\n      {\n        wasAdded: boolean;\n        className: string;\n        astNode: babelTypes.CallExpression;\n      }\n    >;\n    yakImportPath?: NodePath<babelTypes.ImportDeclaration>;\n    runtimeInternalHelpers: Set<string>;\n  }\n> {\n  const { replaces } = options;\n  const rootContext = options.rootContext || process.cwd();\n  const { types: t } = babel;\n\n  /**\n   * A unique prefix for each file to avoid collisions\n   * (generated on first use by hashing the relative file path)\n   */\n  const hashedFilePaths = new WeakMap<BabelFile, string>();\n  const getHashedFilePath = (file: BabelFile) => {\n    const fromCache = hashedFilePaths.get(file);\n    if (fromCache) {\n      return fromCache;\n    }\n    const resourcePath = file.opts.filename;\n    if (!resourcePath) {\n      throw new Error(\"resourcePath is undefined\");\n    }\n    const relativePath = relative(\n      rootContext,\n      resolve(rootContext, resourcePath)\n    );\n    const hashedFilePath = murmurhash2_32_gc(relativePath);\n    hashedFilePaths.set(file, hashedFilePath);\n    return hashedFilePath;\n  };\n\n  /**\n   * Returns wether the given tag is matching a yak import\n   *\n   * e.g.:\n   * - css`...` -> cssLiteral\n   * - styled.div`...` -> styledLiteral\n   * - styled(Component)`...` -> styledCall\n   * - styled.div.attrs({})`...` -> attrsCall\n   * - keyframes`...` -> keyframesLiteral\n   */\n  const getYakExpressionType = (\n    tag: babelTypes.Expression,\n    localVarNames: YakLocalIdentifierNames\n  ) => {\n    if (t.isIdentifier(tag)) {\n      if (tag.name === localVarNames.css) {\n        return \"cssLiteral\";\n      }\n      if (tag.name === localVarNames.keyframes) {\n        return \"keyframesLiteral\";\n      }\n    }\n    if (\n      t.isMemberExpression(tag) &&\n      t.isIdentifier(tag.object) &&\n      tag.object.name === localVarNames.styled\n    ) {\n      return \"styledLiteral\";\n    }\n    if (\n      t.isCallExpression(tag) &&\n      t.isIdentifier(tag.callee) &&\n      tag.callee.name === localVarNames.styled\n    ) {\n      return \"styledCall\";\n    }\n    if (\n      t.isCallExpression(tag) &&\n      t.isMemberExpression(tag.callee) &&\n      t.isIdentifier(tag.callee.property) &&\n      tag.callee.property.name === \"attrs\"\n    ) {\n      return \"attrsCall\";\n    }\n    return \"unknown\";\n  };\n\n  return {\n    name: \"next-yak\",\n    pre() {\n      // Initialize state variables\n      this.localVarNames = {\n        css: undefined,\n        styled: undefined,\n        keyframes: undefined,\n      };\n      this.isImportedInCurrentFile = false;\n      this.classNameCount = 0;\n      this.varIndex = 0;\n      this.variableNameToStyledCall = new Map();\n      this.topLevelConstBindings = new Map();\n      this.runtimeInternalHelpers = new Set();\n    },\n    visitor: {\n      Program: {\n        enter(path, state) {\n          this.topLevelConstBindings = getConstantValues(path, t);\n        },\n        exit(path, state) {\n          if (this.runtimeInternalHelpers.size && this.yakImportPath) {\n            const newImport = t.importDeclaration(\n              [...this.runtimeInternalHelpers].map((helper) =>\n                t.importSpecifier(t.identifier(helper), t.identifier(helper))\n              ),\n              t.stringLiteral(\"next-yak/runtime-internals\")\n            );\n            this.yakImportPath.insertAfter(newImport);\n          }\n        },\n      },\n      /**\n       * Store the name of the imported 'css' and 'styled' variables e.g.:\n       * - `import { css, styled } from 'next-yak'` -> { css: 'css', styled: 'styled' }\n       * - `import { css as yakCss, styled as yakStyled } from 'next-yak'` -> { css: 'yakCss', styled: 'yakStyled' }\n       *\n       * Inject the import to the css-module (with .yak.module.css extension)\n       * e.g. `import './App.yak.module.css!=!./App?./App.yak.module.css'`\n       */\n      ImportDeclaration(path, state) {\n        const node = path.node;\n        if (node.source.value !== \"next-yak\") {\n          return;\n        }\n        const filePath = state.file.opts.filename;\n        if (!filePath) {\n          throw new Error(\"filePath is undefined\");\n        }\n        const fileName = basename(filePath).replace(/\\.tsx?/, \"\");\n        // Import 'next-yak' styles and assign to '__styleYak'\n        // use webpacks !=! syntax to pretend that the typescript file is actually a css-module\n        path.insertAfter(\n          t.importDeclaration(\n            [t.importDefaultSpecifier(t.identifier(\"__styleYak\"))],\n            t.stringLiteral(\n              `./${fileName}.yak.module.css!=!./${fileName}?./${fileName}.yak.module.css`\n            )\n          )\n        );\n        this.yakImportPath = path;\n\n        // Process import specifiers\n        node.specifiers.forEach((specifier) => {\n          if (\n            !(\"imported\" in specifier) ||\n            !specifier.imported ||\n            !t.isIdentifier(specifier.imported)\n          ) {\n            return;\n          }\n\n          const importSpecifier = specifier.imported;\n          const localSpecifier = specifier.local || importSpecifier;\n\n          if (\n            importSpecifier.name === \"styled\" ||\n            importSpecifier.name === \"css\" ||\n            importSpecifier.name === \"keyframes\"\n          ) {\n            this.localVarNames[importSpecifier.name] = localSpecifier.name;\n            this.isImportedInCurrentFile = true;\n          }\n        });\n      },\n      /**\n       * Replace the tagged template expression\n       *  - css`...`\n       * - styled.div`...`\n       * - styled(Component)`...`\n       * - styled.div.attrs({})`...`\n       * - keyframes`...`\n       */\n      TaggedTemplateExpression(path, state) {\n        if (!this.isImportedInCurrentFile) {\n          return;\n        }\n        const tag = path.node.tag;\n\n        // Check if the tag name matches the imported 'css' or 'styled' variable\n        const expressionType = getYakExpressionType(tag, this.localVarNames);\n        if (expressionType === \"unknown\") {\n          return;\n        }\n\n        const styledApi =\n          expressionType === \"styledLiteral\" ||\n          expressionType === \"styledCall\" ||\n          expressionType === \"attrsCall\";\n\n        replaceQuasiExpressionTokens(\n          path.node.quasi,\n          (name) => {\n            // Replace constants from .yak files and\n            if (name in replaces) {\n              return replaces[name];\n            }\n            // Replace expressions by the className of the styled component\n            // e.g.\n            // const MyStyledDiv = styled.div`${FOO} { color: red; }`\n            // ->\n            // const MyStyledDiv = styled.div`.selector0 { color: red; }`\n            const styledCall = this.variableNameToStyledCall.get(name);\n            if (styledCall) {\n              const { wasAdded, className, astNode } = styledCall;\n              // on first usage of another styled component, ensure that\n              // the className of the target component will be added to the DOM\n              if (!wasAdded) {\n                styledCall.wasAdded = true;\n                astNode.arguments.unshift(\n                  t.memberExpression(\n                    t.identifier(\"__styleYak\"),\n                    t.identifier(className)\n                  )\n                );\n              }\n              return className;\n            }\n            return false;\n          },\n          t\n        );\n\n        // Store class name for the created variable for later replacements\n        // e.g. const MyStyledDiv = styled.div`color: red;`\n        // \"MyStyledDiv\" -> \"selector-0\"\n        const variableName =\n          styledApi || expressionType === \"keyframesLiteral\"\n            ? getStyledComponentName(path)\n            : expressionType === \"cssLiteral\"\n            ? getCssName(path)\n            : null;\n\n        const identifier = localIdent(\n          variableName || \"_yak\",\n          variableName && expressionType !== \"cssLiteral\"\n            ? null\n            : this.classNameCount++,\n          expressionType === \"keyframesLiteral\" ? \"animation\" : \"className\"\n        );\n\n        let literalSelectorWasUsed = false;\n        // AutoGenerate a unique className for the current template literal\n        const classNameExpression = t.memberExpression(\n          t.identifier(\"__styleYak\"),\n          t.identifier(identifier)\n        );\n\n        /**\n         * The expression is replaced with a call to the 'styled' or 'css' function\n         * e.g. styled.div`` -> styled.div(...)\n         * e.g. css`` -> css(...)\n         * newArguments is a set of all arguments that will be passed to the function\n         */\n        const newArguments = new Set<babelTypes.Expression>();\n        const quasis = path.node.quasi.quasis;\n        let currentNestingScopes: string[] = [];\n        const quasiTypes = quasis.map((quasi) => {\n          const classification = quasiClassifier(\n            quasi.value.raw,\n            currentNestingScopes\n          );\n          currentNestingScopes = classification.currentNestingScopes;\n          return classification;\n        });\n\n        const expressions = path.node.quasi.expressions.filter(\n          (expression): expression is babelTypes.Expression =>\n            t.isExpression(expression)\n        );\n\n        let cssVariablesInlineStyle;\n\n        // Add the className if the template literal contains css\n        if (\n          quasiTypes.length > 1 ||\n          (quasiTypes.length === 1 && !quasiTypes[0].empty)\n        ) {\n          newArguments.add(classNameExpression);\n          literalSelectorWasUsed = true;\n        }\n\n        let wasInsideCssValue = false;\n        for (let i = 0; i < quasis.length; i++) {\n          const expression = expressions[i];\n          // loop over all quasis belonging to the same css block\n          const type = quasiTypes[i];\n          if (type.unknownSelector) {\n            const expression = expressions[i - 1];\n            if (!expression) {\n              throw new Error(`Invalid css \"${quasis[i].value.raw}\"`);\n            }\n            throw new InvalidPositionError(\n              \"Expressions are not allowed as selectors\",\n              expression,\n              this.file\n            );\n          }\n\n          // expressions after a partial css are converted into css variables\n          if (\n            expression &&\n            (type.unknownSelector ||\n              type.insideCssValue ||\n              (type.empty && wasInsideCssValue))\n          ) {\n            wasInsideCssValue = true;\n            // to prevent overuse of css variables, we only allow expressions\n            // for css variables for arrow function expressions\n            const variableName = getConstantName(expression, t);\n            if (variableName && this.topLevelConstBindings.has(variableName)) {\n              // Ignore constants that have a static string or number value\n              const value = this.topLevelConstBindings.get(variableName);\n              if (value !== null) {\n                continue;\n              }\n\n              throw new InvalidPositionError(\n                \"Possible constant used as runtime value for a css variable\\n\" +\n                  \"Please move the constant to a .yak import or use an arrow function\\n\" +\n                  \"e.g.:\\n\" +\n                  \"|   import { primaryColor } from './foo.yak'\\n\" +\n                  \"|   const MyStyledDiv = styled.div`color: ${primaryColor};`\",\n                expression,\n                this.file\n              );\n            }\n\n            if (!cssVariablesInlineStyle) {\n              cssVariablesInlineStyle = t.objectExpression([]);\n            }\n            const cssVariableName = `--ðŸ¦¬${getHashedFilePath(state.file)}${this\n              .varIndex++}`;\n\n            // Extracts the css unit from a css string after the current expression\n            const cssUnit = quasis[i + 1]?.value.raw.match(/^([a-z]+|%)/i)?.[0];\n            const transformedExpression = cssUnit\n              ? appendCssUnitToExpressionValue(\n                  cssUnit,\n                  expression,\n                  this.runtimeInternalHelpers,\n                  t\n                )\n              : expression;\n\n            // expression: `x`\n            // { style: { --v0: x}}\n            cssVariablesInlineStyle.properties.push(\n              t.objectProperty(\n                t.stringLiteral(cssVariableName),\n                transformedExpression\n              )\n            );\n          }\n          // handle mixins\n          else {\n            wasInsideCssValue = false;\n            if (expression) {\n              if (quasiTypes[i].currentNestingScopes.length > 0) {\n                // inside a nested scope a foreign css literal must not be used\n                // as we can not forward the scope\n                const isReferenceToMixin =\n                  t.isIdentifier(expression) || t.isCallExpression(expression);\n                if (isReferenceToMixin) {\n                  throw new InvalidPositionError(\n                    `Mixins are not allowed inside nested selectors`,\n                    expression,\n                    this.file,\n                    \"Use an inline css literal instead or move the selector into the mixin\"\n                  );\n                }\n              }\n              newArguments.add(expression);\n            }\n          }\n        }\n\n        // Add the inline style object to the arguments\n        // e.g. styled.div`color: ${x};` -> styled.div({ style: { --yak43: x } })\n        if (cssVariablesInlineStyle) {\n          newArguments.add(\n            t.objectExpression([\n              t.objectProperty(\n                t.stringLiteral(`style`),\n                cssVariablesInlineStyle\n              ),\n            ])\n          );\n        }\n\n        const styledCall = t.callExpression(tag, [...newArguments]);\n        path.replaceWith(styledCall);\n\n        // Store the AST node of the `styled` node for later selector replacements\n        // e.g.\n        // const MyStyledDiv = styled.div`color: red;`\n        // const Bar = styled.div` ${MyStyledDiv} { color: blue }`\n        // \"${MyStyledDiv} {\" -> \".selector-0 {\"\n        if (styledApi && variableName) {\n          this.variableNameToStyledCall.set(variableName, {\n            wasAdded: literalSelectorWasUsed,\n            className: identifier,\n            astNode: styledCall,\n          });\n        }\n      },\n    },\n  };\n}\n\nexport class InvalidPositionError extends Error {\n  /**\n   * Add the expression code that caused the error to the message\n   * for better debugging\n   */\n  constructor(\n    message: string,\n    expression: babelTypes.Expression,\n    file: BabelFile,\n    recommendedFix?: string\n  ) {\n    let errorText = message;\n    const line = expression.loc?.start.line ?? -1;\n    if (line !== -1) {\n      errorText = `line ${line}: ${errorText}`;\n    }\n    if (expression.start && expression.end) {\n      errorText += `\\nfound: \\${${file.code.slice(\n        expression.start,\n        expression.end\n      )}}`;\n    }\n    if (recommendedFix) {\n      errorText += `\\n${recommendedFix}`;\n    }\n    super(errorText);\n  }\n}\n","import babel, { BabelFileResult } from \"@babel/core\";\nimport getYakImports from \"./lib/getYakImports.js\";\nimport { InvalidPositionError } from \"./babel-yak-plugin.js\";\n\n/**\n * Loader for typescript files that use yak, it replaces the css template literal with a call to the 'styled' function\n */\nexport default async function tsloader(\n  this: any,\n  source: string\n): Promise<string | void> {\n  // ignore files if they don't use yak\n  if (!source.includes(\"next-yak\")) {\n    return source;\n  }\n  const callback = this.async();\n  const { rootContext, resourcePath } = this;\n\n  /** .yak files are constant definition files */\n  const isYakFile = /\\.yak\\.(j|t)sx?$/.test(resourcePath.matches);\n  // The user may import constants from a .yak file\n  // e.g. import { primary } from './colors.yak'\n  //\n  // However .yak files inside .yak files are not be compiled\n  // to avoid performance overhead\n  const importedYakConstants = isYakFile ? [] : getYakImports(source);\n  const replaces: Record<string, unknown> = {};\n  await Promise.all(\n    importedYakConstants.map(async ({ imports, from }) => {\n      const constantValues = await this.importModule(from, {\n        layer: \"yak-importModule\",\n      });\n      imports.forEach(({ localName, importedName }) => {\n        replaces[localName] = constantValues[importedName];\n      });\n    })\n  );\n\n  let result: BabelFileResult | null = null;\n  try {\n    // Compile the typescript file with babel - this will:\n    // - inject the import to the css-module (with .yak.module.css extension)\n    // - replace the css template literal with styles from the css-module\n    result = babel.transformSync(source, {\n      filename: resourcePath,\n      configFile: false,\n      plugins: [\n        [\n          \"@babel/plugin-syntax-typescript\",\n          { isTSX: this.resourcePath.endsWith(\".tsx\") },\n        ],\n        [\n          await import(\"./babel-yak-plugin.js\").then((m) => m.default),\n          {\n            replaces,\n            rootContext,\n          },\n        ],\n      ],\n    });\n  } catch (error) {\n    if (error instanceof InvalidPositionError) {\n      return callback(new Error(error.message));\n    }\n    return callback(new Error(\"babel transform failed\"));\n  }\n  if (!result?.code) {\n    return callback(new Error(\"babel transform failed\"));\n  }\n  return callback(null, result.code, result.map);\n}\n","/**\n * Finds all imports in a given code string which import from a .yak file\n *\n * Uses regex to work with typescript and javascript\n * Does not support lazy imports\n */\nconst getYakImports = (code: string) => {\n  const codeWithoutComments = code.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n  const allImports = codeWithoutComments.matchAll(\n    /(^|\\n|;)\\s*import\\s+(?:(\\w+(?:\\s+as\\s+\\w+)?)\\s*,?\\s*)?(?:{([^}]*)})?\\s+from\\s+[\"']([^'\"]+\\.yak)[\"'](;|\\n)/g\n  );\n  return [...allImports].map(([, , defaultImport, namedImports, from]) => {\n    // parse named imports to { localName: string, importedName: string }[]\n    const imports =\n      namedImports?.split(\",\").map((namedImport) => {\n        const [importedName, localName = importedName] = namedImport\n          .replace(/^type\\s+/, \"\")\n          .trim()\n          .split(/\\s+as\\s+/);\n        return { localName, importedName };\n      }) ?? [];\n    // parse default import to { localName: string, importedName: string }[]\n    if (defaultImport) {\n      imports.push(parseDefaultImport(defaultImport));\n    }\n    return { imports, from };\n  });\n};\n\n/**\n * Parses a default import string\n */\nfunction parseDefaultImport(defaultImport: string) {\n  const defaultImportArray = defaultImport.split(/\\s+as\\s+/);\n  return {\n    localName: defaultImportArray[1] ?? defaultImportArray[0],\n    importedName: defaultImportArray[0],\n  };\n}\n\nexport default getYakImports;\n"],"mappings":"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","names":["getStyledComponentName","babel","styledCall","expression","variableName"]}