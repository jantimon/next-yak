{"version":3,"sources":["lib/getYakImports.ts","cssloader.ts","lib/stripCssComments.ts","lib/quasiClassifier.ts","lib/localIdent.ts","lib/replaceQuasiExpressionTokens.ts","lib/getStyledComponentName.ts","lib/getCssName.ts","lib/hash.ts","lib/getConstantValues.ts"],"sourcesContent":["/**\n * Finds all imports in a given code string which import from a .yak file\n *\n * Uses regex to work with typescript and javascript\n * Does not support lazy imports\n */\nconst getYakImports = (code: string) => {\n  const codeWithoutComments = code.replace(/\\/\\*[\\s\\S]*?\\*\\//g, \"\");\n  const allImports = codeWithoutComments.matchAll(\n    /(^|\\n|;)\\s*import\\s+(?:(\\w+(?:\\s+as\\s+\\w+)?)\\s*,?\\s*)?(?:{([^}]*)})?\\s+from\\s+[\"']([^'\"]+\\.yak)[\"'](;|\\n)/g\n  );\n  return [...allImports].map(([, , defaultImport, namedImports, from]) => {\n    // parse named imports to { localName: string, importedName: string }[]\n    const imports =\n      namedImports?.split(\",\").map((namedImport) => {\n        const [importedName, localName = importedName] = namedImport\n          .replace(/^type\\s+/, \"\")\n          .trim()\n          .split(/\\s+as\\s+/);\n        return { localName, importedName };\n      }) ?? [];\n    // parse default import to { localName: string, importedName: string }[]\n    if (defaultImport) {\n      imports.push(parseDefaultImport(defaultImport));\n    }\n    return { imports, from };\n  });\n};\n\n/**\n * Parses a default import string\n */\nfunction parseDefaultImport(defaultImport: string) {\n  const defaultImportArray = defaultImport.split(/\\s+as\\s+/);\n  return {\n    localName: defaultImportArray[1] ?? defaultImportArray[0],\n    importedName: defaultImportArray[0],\n  };\n}\n\nexport default getYakImports;\n","import getYakImports from \"./lib/getYakImports.js\";\nimport babel, { NodePath } from \"@babel/core\";\nimport quasiClassifier from \"./lib/quasiClassifier.js\";\nimport localIdent from \"./lib/localIdent.js\";\nimport replaceQuasiExpressionTokens from \"./lib/replaceQuasiExpressionTokens.js\";\nimport getStyledComponentName from \"./lib/getStyledComponentName.js\";\nimport getCssName from \"./lib/getCssName.js\";\nimport murmurhash2_32_gc from \"./lib/hash.js\";\nimport { relative } from \"path\";\nimport { getConstantName, getConstantValues } from \"./lib/getConstantValues.js\";\nimport { Identifier, TaggedTemplateExpression } from \"@babel/types\";\n\n// A CssPartExpression is the css code block for each tagged template expression\ntype CssPartExpression = {\n  selector: string;\n  hasParent: boolean;\n  quasiCode: Array<{ insideCssValue: boolean; code: string }>;\n  cssPartExpressions: { [key: number]: CssPartExpression[] };\n};\n\nexport default async function cssLoader(\n  this: any,\n  source: string\n): Promise<string> {\n  const { rootContext, resourcePath } = this;\n\n  /** .yak files are constant definition files */\n  const isYakFile = /\\.yak\\.(j|t)sx?$/.test(resourcePath.matches);\n  // The user may import constants from a yak file\n  // e.g. import { primary } from './colors.yak'\n  //\n  // However .yak files inside .yak files are not be compiled\n  // to avoid performance overhead\n  const importedYakConstants = isYakFile ? [] : getYakImports(source);\n  const replaces: Record<string, unknown> = {};\n  await Promise.all(\n    importedYakConstants.map(async ({ imports, from }) => {\n      const constantValues = await this.importModule(from, {\n        layer: \"yak-importModule\",\n      });\n      imports.forEach(({ localName, importedName }) => {\n        replaces[localName] = constantValues[importedName];\n      });\n    })\n  );\n\n  // parse source with babel\n  const ast = babel.parseSync(source, {\n    filename: this.resourcePath,\n    configFile: false,\n    plugins: [\n      [\n        \"@babel/plugin-syntax-typescript\",\n        { isTSX: this.resourcePath.endsWith(\".tsx\") },\n      ],\n    ],\n  });\n\n  if (ast === null) {\n    return \"\";\n  }\n\n  const { types: t } = babel;\n\n  const localVarNames: {\n    css: string | undefined;\n    styled: string | undefined;\n    attrs: string;\n    keyframes: string | undefined;\n  } = {\n    css: undefined,\n    styled: undefined,\n    attrs: \"attrs\",\n    keyframes: undefined,\n  };\n\n  /**\n   * find all css template literals in the ast\n   *\n   * Babel iterates over the full TaggedLiteralExpression before it iterates over their children\n   * To keep the order as written in the original code the code fragments are stored in an ordered map\n   */\n  const cssParts = new Map<\n    NodePath<TaggedTemplateExpression>,\n    CssPartExpression\n  >();\n\n  let index = 0;\n  let varIndex = 0;\n  let hashedFile: string | null = null;\n\n  const variableNameToStyledClassName = new Map<string, string>();\n  let topLevelConstBindings = new Map<string, number | string | null>();\n\n  babel.traverse(ast, {\n    Program(path) {\n      topLevelConstBindings = getConstantValues(path, t);\n    },\n    ImportDeclaration(path) {\n      const node = path.node;\n      if (node.source.value !== \"next-yak\") {\n        return;\n      }\n      // Process import specifiers\n      node.specifiers.forEach((specifier) => {\n        if (\n          !(\"imported\" in specifier) ||\n          !specifier.imported ||\n          !t.isIdentifier(specifier.imported)\n        ) {\n          return;\n        }\n\n        const importSpecifier =\n          /** @type {babel.types.Identifier} */ specifier.imported;\n        const localSpecifier = specifier.local || importSpecifier;\n        if (\n          importSpecifier.name === \"styled\" ||\n          importSpecifier.name === \"css\" ||\n          importSpecifier.name === \"keyframes\"\n        ) {\n          localVarNames[importSpecifier.name] = localSpecifier.name;\n        }\n      });\n    },\n    /**\n     * @param {import(\"@babel/core\").NodePath<import(\"@babel/types\").TaggedTemplateExpression>} path\n     */\n    TaggedTemplateExpression(path) {\n      // Check if the tag name matches the imported 'css' or 'styled' variable\n      const tag = path.node.tag;\n\n      const isCssLiteral =\n        t.isIdentifier(tag) &&\n        /** @type {babel.types.Identifier} */ tag.name === localVarNames.css;\n\n      const isKeyFrameLiteral =\n        t.isIdentifier(tag) &&\n        /** @type {babel.types.Identifier} */ tag.name ===\n          localVarNames.keyframes;\n\n      const isStyledLiteral =\n        t.isMemberExpression(tag) &&\n        t.isIdentifier(\n          /** @type {babel.types.MemberExpression} */ tag.object\n        ) &&\n        /** @type {babel.types.Identifier} */ /** @type {babel.types.MemberExpression} */ tag\n          .object.name === localVarNames.styled;\n\n      const isStyledCall =\n        t.isCallExpression(tag) &&\n        t.isIdentifier(/** @type {babel.types.CallExpression} */ tag.callee) &&\n        /** @type {babel.types.Identifier} */ /** @type {babel.types.CallExpression} */ tag\n          .callee.name === localVarNames.styled;\n\n      const isAttrsCall =\n        t.isCallExpression(tag) &&\n        t.isMemberExpression(tag.callee) &&\n        (tag.callee.property as Identifier).name === \"attrs\";\n\n      if (\n        !isCssLiteral &&\n        !isKeyFrameLiteral &&\n        !isStyledLiteral &&\n        !isStyledCall &&\n        !isAttrsCall\n      ) {\n        return;\n      }\n\n      replaceQuasiExpressionTokens(\n        path.node.quasi,\n        (name) => {\n          if (name in replaces) {\n            return replaces[name];\n          }\n          if (variableNameToStyledClassName.has(name)) {\n            return variableNameToStyledClassName.get(name);\n          }\n          return false;\n        },\n        t\n      );\n\n      const parentLocation = getClosestTemplateLiteralExpressionParentPath(\n        path,\n        localVarNames\n      );\n\n      // Store class name for the created variable for later replacements\n      // e.g. const MyStyledDiv = styled.div`color: red;`\n      // \"MyStyledDiv\" -> \"selector-0\"\n      const variableName =\n        isStyledLiteral || isStyledCall || isAttrsCall || isKeyFrameLiteral\n          ? getStyledComponentName(path)\n          : isCssLiteral\n          ? getCssName(path)\n          : null;\n\n      const literalSelector = localIdent(\n        variableName || \"_yak\",\n        variableName && !isCssLiteral ? null : index++,\n        isKeyFrameLiteral ? \"keyframes\" : \"selector\"\n      );\n\n      const currentCssParts: CssPartExpression = {\n        quasiCode: [],\n        cssPartExpressions: [],\n        selector: !parentLocation\n          ? literalSelector\n          : `&:where(${literalSelector})`,\n        hasParent: Boolean(parentLocation),\n      };\n      const parentCssParts =\n        parentLocation &&\n        cssParts.get(\n          parentLocation.parent as NodePath<TaggedTemplateExpression>\n        );\n      cssParts.set(path, currentCssParts);\n      if (parentCssParts) {\n        parentCssParts.cssPartExpressions[parentLocation.currentIndex] ||= [];\n        parentCssParts.cssPartExpressions[parentLocation.currentIndex].push(\n          currentCssParts\n        );\n      }\n\n      // Replace the tagged template expression with a call to the 'styled' function\n      const quasis = path.node.quasi.quasis;\n      const quasiTypes = quasis.map((quasi) =>\n        quasiClassifier(quasi.value.raw, [])\n      );\n\n      let wasInsideCssValue = false;\n      let removeCssUnit = false;\n      for (let i = 0; i < quasis.length; i++) {\n        const quasi = quasis[i];\n        const expression = path.node.quasi.expressions[i];\n        // loop over all quasis belonging to the same css block\n        const type = quasiTypes[i];\n\n        let code = unEscapeCssCode(quasi.value.raw);\n        if (removeCssUnit) {\n          // a quasi might start with a css unit e.g. css`margin: ${value}px 0;`\n          // the css unit will be part of the typescript runtime code and must\n          // must be removed from the css code as `var(--foo)px` would be invalid css\n          code = code.replace(/^([a-z]+|%)/i, \"\");\n          removeCssUnit = false;\n        }\n\n        // expressions after a partial css are converted into css variables\n        if (\n          expression &&\n          (type.unknownSelector ||\n            type.insideCssValue ||\n            (type.empty && wasInsideCssValue))\n        ) {\n          wasInsideCssValue = true;\n          if (!hashedFile) {\n            const relativePath = relative(rootContext, resourcePath);\n            hashedFile = murmurhash2_32_gc(relativePath);\n          }\n          const variableName =\n            t.isExpression(expression) && getConstantName(expression, t);\n          const variableConstValue =\n            variableName && topLevelConstBindings.get(variableName);\n          if (variableConstValue === null || variableConstValue === undefined) {\n            currentCssParts.quasiCode.push({\n              insideCssValue: true,\n              code:\n                code +\n                // replace the expression with a css variable\n                `var(--ðŸ¦¬${hashedFile}${varIndex++})`,\n            });\n            removeCssUnit = true;\n          } else {\n            currentCssParts.quasiCode.push({\n              insideCssValue: true,\n              code: code + String(variableConstValue),\n            });\n          }\n        } else {\n          wasInsideCssValue = false;\n          // code is added\n          // empty quasis are also added to keep spacings\n          // e.g. `transition: color ${duration} ${easing};`\n          currentCssParts.quasiCode.push({\n            code,\n            insideCssValue: false,\n          });\n        }\n      }\n\n      // Store class name of the created variable for later selector replacements\n      // e.g.\n      // const MyStyledDiv = styled.div`color: red;`\n      // const Bar = styled.div` ${MyStyledDiv} { color: blue }`\n      // \"${MyStyledDiv} {\" -> \".selector-0 {\"\n      if (variableName && (isStyledLiteral || isStyledCall || isAttrsCall)) {\n        variableNameToStyledClassName.set(variableName, literalSelector);\n      }\n    },\n  });\n  const rootCssParts = [...cssParts.values()].filter(\n    ({ hasParent }) => !hasParent\n  );\n\n  return mergeCssPartExpression(rootCssParts).trim();\n}\n\n/**\n * In jscode slashes are escaped however in css code they are not\n * e.g. in javascript `:before { content: \"\\\\f0c9\"; }` would be `:before { content: \"\\f0c9\"; }` in css\n * slashes are still possible with `:before { content: \"\\\\\\\\\"; }`\n */\nconst unEscapeCssCode = (code: string) => code.replace(/\\\\\\\\/gi, \"\\\\\");\n\n/**\n * Searches the closest parent TaggedTemplateExpression using a name from localNames\n * Returns the location inside this parent\n */\nconst getClosestTemplateLiteralExpressionParentPath = (\n  path: NodePath<TaggedTemplateExpression>,\n  { css, styled }: { css?: string; styled?: string }\n) => {\n  let grandChild: NodePath = path;\n  let child: NodePath = path;\n  let parent = path.parentPath;\n  const t = babel.types;\n  while (parent) {\n    if (t.isTaggedTemplateExpression(parent.node)) {\n      const tag = parent.node.tag;\n      const isCssLiteral =\n        t.isIdentifier(tag) &&\n        /** @type {babel.types.Identifier} */ tag.name === css;\n      const isStyledLiteral =\n        t.isMemberExpression(tag) &&\n        t.isIdentifier(\n          /** @type {babel.types.MemberExpression} */ tag.object\n        ) &&\n        /** @type {babel.types.Identifier} */ /** @type {babel.types.MemberExpression} */ tag\n          .object.name === styled;\n      const isStyledCall =\n        t.isCallExpression(tag) &&\n        t.isIdentifier(/** @type {babel.types.CallExpression} */ tag.callee) &&\n        /** @type {babel.types.Identifier} */ /** @type {babel.types.CallExpression} */ tag\n          .callee.name === styled;\n      const isAttrsCall =\n        t.isCallExpression(tag) &&\n        t.isMemberExpression(tag.callee) &&\n        (tag.callee.property as Identifier).name === \"attrs\";\n      if (isCssLiteral || isStyledLiteral || isStyledCall || isAttrsCall) {\n        if (\n          !t.isTemplateLiteral(child.node) ||\n          !t.isExpression(grandChild.node)\n        ) {\n          throw new Error(\"Broken AST\");\n        }\n        const currentIndex = child.node.expressions.indexOf(grandChild.node);\n        return {\n          parent:\n            /** @type {import(\"@babel/core\").NodePath<import(\"@babel/types\").TaggedTemplateExpression>} */ parent,\n          currentIndex,\n        };\n      }\n    }\n    if (!parent.parentPath) {\n      return null;\n    }\n    grandChild = child;\n    child = parent;\n    parent = parent.parentPath;\n  }\n  return null;\n};\n\n/**\n * depthFirst traversal of the css parts\n */\nconst mergeCssPartExpression = (\n  cssPartExpression: CssPartExpression[],\n  level = 0\n) => {\n  let css = \"\";\n  for (const { quasiCode, cssPartExpressions, selector } of cssPartExpression) {\n    let cssPart = \"\";\n    for (let i = 0; i < quasiCode.length; i++) {\n      const quasi = quasiCode[i];\n      cssPart += trimNewLines(quasi.code);\n      // Add expressions from child css literals\n      const childCssParts = cssPartExpressions[i];\n      if (childCssParts) {\n        cssPart += `\\n${trimNewLines(\n          mergeCssPartExpression(childCssParts, level + 1)\n        )}\\n`;\n      }\n    }\n    // Try to keep the same indentation as the original code\n    const indent =\n      quasiCode[0]?.code.match(/^\\n(  |\\t)(\\s*)/)?.[2] ?? \"    \".repeat(level);\n    const hasCss = Boolean(cssPart.trim());\n    css += !hasCss\n      ? \"\"\n      : `${indent}${selector} {\\n${trimNewLines(cssPart)}\\n${indent}}\\n`;\n  }\n  return css;\n};\n\nconst trimNewLines = (str: string) => str.replace(/^\\s*\\n+|\\s+$/g, \"\");\n","// from https://github.com/sindresorhus/strip-css-comments/tree/main\nexport default function stripCssComments(cssString: string) {\n  let isInsideString: string | false = false;\n  let currentCharacter = \"\";\n  let comment = \"\";\n  let returnValue = \"\";\n\n  for (let index = 0; index < cssString.length; index++) {\n    currentCharacter = cssString[index];\n\n    if (\n      cssString[index - 1] !== \"\\\\\" &&\n      (currentCharacter === '\"' || currentCharacter === \"'\")\n    ) {\n      if (isInsideString === currentCharacter) {\n        isInsideString = false;\n      } else if (!isInsideString) {\n        isInsideString = currentCharacter;\n      }\n    }\n\n    // Find beginning of `/*` type comment\n    if (\n      !isInsideString &&\n      currentCharacter === \"/\" &&\n      cssString[index + 1] === \"*\"\n    ) {\n      let index2 = index + 2;\n\n      // Iterate over comment\n      for (; index2 < cssString.length; index2++) {\n        // Find end of comment\n        if (cssString[index2] === \"*\" && cssString[index2 + 1] === \"/\") {\n          if (cssString[index2 + 2] === \"\\n\") {\n            index2++;\n          } else if (cssString[index2 + 2] + cssString[index2 + 3] === \"\\r\\n\") {\n            index2 += 2;\n          }\n          comment = \"\";\n          break;\n        }\n        // Store comment text\n        comment += cssString[index2];\n      }\n      // Resume iteration over CSS string from the end of the comment\n      index = index2 + 1;\n      continue;\n    }\n    returnValue += currentCharacter;\n  }\n  return returnValue;\n}\n","import stripCssComments from \"./stripCssComments.js\";\n\n/**\n * Checks a quasiValue and returns its type\n *\n * - empty: no expressions, no text\n * - unknownSelector: starts with a `{` e.g. `{ opacity: 0.5; }` or `,` e.g. `, bar { ... }`\n * - insideCssValue: does not end with a `{` or `}` or `;` e.g. `color: `\n */\nexport default function quasiClassifier(\n  quasiValue: string,\n  currentNestingScopes: string[]\n) {\n  // TODO - for better performance we could move the comment skipping logic\n  // directly in the for loop below instead of calling stripCssComments\n  const trimmedCssString = stripCssComments(quasiValue).trim();\n  if (trimmedCssString === \"\") {\n    return {\n      empty: true,\n      unknownSelector: false,\n      insideCssValue: false,\n      currentNestingScopes,\n    };\n  }\n  let isInsideString: '\"' | \"'\" | false = false;\n  let currentCharacter = \"\";\n  let newNestingLevel = [...currentNestingScopes];\n  let currentSelector = \"\";\n  for (let index = 0; index < trimmedCssString.length; index++) {\n    currentCharacter = trimmedCssString[index];\n    if (\n      trimmedCssString[index - 1] !== \"\\\\\" &&\n      (currentCharacter === '\"' || currentCharacter === \"'\")\n    ) {\n      if (isInsideString === currentCharacter) {\n        isInsideString = false;\n      } else if (!isInsideString) {\n        isInsideString = currentCharacter;\n      }\n    }\n    if (isInsideString) {\n      continue;\n    }\n    if (currentCharacter === \"{\") {\n      const selector = currentSelector.trim();\n      if (selector !== \"\") {\n        newNestingLevel.push(selector);\n      }\n      // after an opening bracket a new selector might start e.g.:\n      // .class {\n      //   .nested-class {\n      currentSelector = \"\";\n    } else if (currentCharacter === \"}\") {\n      newNestingLevel.pop();\n      // after a closing bracket a new selector might start e.g.:\n      // .class {\n      //   color: red;\n      // }\n      // .other-class {\n      currentSelector = \"\";\n    } else if (currentCharacter === \";\") {\n      // after a semi-colon a nested selector might start e.g.:\n      // .class {\n      //   color: red;\n      //   .nested-class {\n      currentSelector = \"\";\n    } else {\n      currentSelector += currentCharacter;\n    }\n  }\n\n  return {\n    empty: false,\n    unknownSelector: trimmedCssString[0] === \"{\" || trimmedCssString[0] === \",\",\n    insideCssValue:\n      currentCharacter !== \"{\" &&\n      currentCharacter !== \"}\" &&\n      currentCharacter !== \";\",\n    currentNestingScopes: newNestingLevel,\n  };\n}\n","/**\n * Generates local names used in the generated CSS.\n * It is also used in the js code to reference the generated CSS.\n *\n * E.g.:\n * ```ts\n * localIdent(\"myVariableName\", 1, \"selector\") // \".myVariableName_1\"\n * localIdent(\"myVariableName\", 1, \"className\") // \"myVariableName_1\"\n * localIdent(\"myVariableName\", 1, \"keyframes\") // \"@keyframes myVariableName_1\"\n * localIdent(\"myVariableName\", 1, \"animation\") // \"myVariableName_1\"\n * ```\n */\nexport default function localIdent(\n  variableName: string,\n  i: number | null,\n  kind: \"selector\" | \"className\" | \"keyframes\" | \"animation\"\n) {\n  switch (kind) {\n    case \"selector\":\n      return `.${variableName}${i === null ? \"\" : `_${i}`}`;\n    case \"className\":\n    case \"animation\":\n      return `${variableName}${i === null ? \"\" : `_${i}`}`;\n    case \"keyframes\":\n      return `@keyframes ${variableName}${i === null ? \"\" : `_${i}`}`;\n    default:\n      throw new Error(\"unknown kind\");\n  }\n}\n","import type { NodePath, types as babelTypes } from \"@babel/core\";\n\n/**\n * Replace tokens with predefined values e.g.\n *\n * ```js\n *  css`\n *    color: red;\n *    ${query.xs} {\n *      color: blue;\n *   }\n * `\n *\n * ```\n * becomes\n * ```js\n * css`\n *  color: red;\n *  @media (min-width: 0px) {\n *    color: blue;\n * }\n * `\n * ```\n */\nexport default function replaceTokensInQuasiExpressions(\n  quasi: babelTypes.TemplateLiteral,\n  replacer: (name: string) => unknown,\n  t: typeof babelTypes\n) {\n  // Iterate over the expressions in reverse order\n  // so removing items won't affect the index of the next item\n  for (let i = quasi.expressions.length - 1; i >= 0; i--) {\n    const expression = quasi.expressions[i];\n    // break the expression into parts\n    // e.g. x.y.z -> [\"x\", \"y\", \"z\"]\n    const parts = getExpressionParts(expression, t);\n    // find the replacement for the expression\n    const replacement = parts && replacer(parts[0]);\n    // if it is a nested value, find the value of the expression\n    // e.g. x.y.z -> find the value of z\n    const replacementValue =\n      replacement && getReplacementValue(replacement, parts);\n    if (replacementValue !== false && replacementValue !== null) {\n      replaceExpressionAndMergeQuasis(quasi, i, replacementValue);\n    }\n  }\n}\n\n/**\n * Replace tokens with predefined values\n */\nfunction replaceExpressionAndMergeQuasis(\n  quasi: babelTypes.TemplateLiteral,\n  expressionIndex: number,\n  replacement: unknown\n) {\n  const stringReplacement =\n    typeof replacement === \"string\"\n      ? replacement\n      : replacement == null\n      ? \"\"\n      : JSON.stringify(replacement);\n  quasi.expressions.splice(expressionIndex, 1);\n  quasi.quasis[expressionIndex].value.raw +=\n    stringReplacement + quasi.quasis[expressionIndex + 1].value.raw;\n  quasi.quasis[expressionIndex].value.cooked +=\n    stringReplacement + quasi.quasis[expressionIndex + 1].value.cooked;\n  quasi.quasis.splice(expressionIndex + 1, 1);\n}\n\n/**\n * Find the replacement for the expression\n *\n * searches for:\n *   - `x` -> [\"x\"]\n *   - `x.y` -> [\"x\", \"y\"]\n *   - `x[0]` -> [\"x\", 0]\n *   - `x()` -> [\"x\"]\n *   - `x.y()` -> [\"x\", \"y\"]\n *   - (1 + 2) -> null\n */\nfunction getExpressionParts(\n  expression: babelTypes.Expression | babelTypes.TSType,\n  t: typeof babelTypes\n) {\n  let currentExpression = expression;\n  /** @type {string[]} */\n  const tokens = [];\n  while (currentExpression) {\n    // e.g. x\n    if (t.isIdentifier(currentExpression)) {\n      tokens.unshift(currentExpression.name);\n      break;\n    }\n    // e.g. x.y\n    if (t.isMemberExpression(currentExpression)) {\n      if (\n        currentExpression.computed === false &&\n        t.isIdentifier(currentExpression.property)\n      ) {\n        tokens.unshift(currentExpression.property.name);\n      } else if (t.isStringLiteral(currentExpression.property)) {\n        tokens.unshift(currentExpression.property.value);\n      } else if (t.isNumericLiteral(currentExpression.property)) {\n        tokens.unshift(String(currentExpression.property.value));\n      } else {\n        return null;\n      }\n      currentExpression = currentExpression.object;\n    } else if (t.isCallExpression(currentExpression)) {\n      if (!t.isExpression(currentExpression.callee)) {\n        return null;\n      }\n      currentExpression = currentExpression.callee;\n    } else {\n      return null;\n    }\n  }\n  return tokens;\n}\n\n/**\n * Get the value of the replacement\n *\n * e.g. for `replacement.x.y[0]` and `replacement = { x: { y: [42] } }`\n * parts = [\"replacement\", \"x\", \"y\", 0]\n * --> 42\n */\nfunction getReplacementValue(replacement: any, parts: string[]) {\n  let currentReplacement = replacement;\n  for (let i = 1; i < parts.length; i++) {\n    const part = parts[i];\n    if (currentReplacement == null || typeof currentReplacement !== \"object\") {\n      return false;\n    }\n    currentReplacement = currentReplacement[part];\n  }\n  return currentReplacement;\n}\n","import type { NodePath, types as babelTypes } from \"@babel/core\";\n\n/**\n * Try to get the name of a styled component from a call or member expression\n *\n * e.g. const MyButton = styled.div`...` -> \"MyButton\"\n * e.g. const FancyButton = styled(MyButton)`...` -> \"FancyButton\"\n */\nconst getStyledComponentName = (\n  taggedTemplateExpressionPath: NodePath<babelTypes.TaggedTemplateExpression>\n) => {\n  const variableDeclaratorPath = taggedTemplateExpressionPath.findParent(\n    (path) => path.isVariableDeclarator()\n  );\n  if (\n    !variableDeclaratorPath ||\n    !(\"id\" in variableDeclaratorPath.node) ||\n    variableDeclaratorPath.node.id?.type !== \"Identifier\"\n  ) {\n    throw new Error(\n      \"Could not find variable declaration for styled component at \" +\n        taggedTemplateExpressionPath.node.loc\n    );\n  }\n  return variableDeclaratorPath.node.id.name;\n};\n\nexport default getStyledComponentName;\n","import type { NodePath, types as babelTypes } from \"@babel/core\";\n\n/**\n * Extracts the conditions from a path\n */\nfunction extractConditions(\n  path: NodePath<babelTypes.TaggedTemplateExpression>\n) {\n  const conditions: string[] = [];\n  const visitedNodes = new Set();\n  const getConditions = (\n    node: babelTypes.Node,\n    previousNode: babelTypes.Node,\n    isNegated = false\n  ) => {\n    if (visitedNodes.has(node)) return;\n    visitedNodes.add(node);\n    // Support for && and || operators e.g. disabled && \"disabled\"\n    if (node.type === \"LogicalExpression\") {\n      if (node.operator === \"&&\") {\n        getConditions(node.right, previousNode, isNegated);\n        conditions.push(\"and\");\n        getConditions(node.left, previousNode, isNegated);\n      } else if (node.operator === \"||\") {\n        getConditions(node.right, previousNode, isNegated);\n        conditions.push(\"or\");\n        getConditions(node.left, previousNode, isNegated);\n      }\n    }\n    // Support for ternary operator e.g. disabled ? \"disabled\" : \"enabled\"\n    else if (node.type === \"ConditionalExpression\") {\n      conditions.push(\"and\");\n      getConditions(node.test, previousNode, node.alternate === previousNode);\n    }\n    // Support for ! operator e.g. !disabled\n    else if (node.type === \"UnaryExpression\" && node.operator === \"!\") {\n      getConditions(node.argument, previousNode, !isNegated);\n    }\n    // Support for Boolean() function e.g. Boolean(disabled)\n    else if (\n      node.type === \"CallExpression\" &&\n      node.callee.type === \"Identifier\" &&\n      node.callee.name === \"Boolean\"\n    ) {\n      getConditions(node.arguments[0], previousNode, isNegated);\n    }\n    // Get the name of the variable e.g. disabled\n    else if (node.type === \"Identifier\") {\n      conditions.push((isNegated ? \"not_\" : \"\") + node.name);\n    }\n    // Get the name of a member expression e.g. props.disabled\n    else if (node.type === \"MemberExpression\") {\n      conditions.push(\n        (isNegated ? \"not_\" : \"\") + getMemberExpressionName(node)\n      );\n    }\n  };\n  let currentPath: NodePath | null = path;\n  let previousPath: NodePath = path;\n  while (currentPath) {\n    getConditions(currentPath.node, previousPath.node);\n    previousPath = currentPath;\n    currentPath = currentPath.parentPath;\n  }\n  if (conditions[0] === \"or\" || conditions[0] === \"and\") {\n    conditions.shift();\n  }\n  return conditions.reverse();\n}\n\n/**\n * Try to get the name of a css component from a literal expression\n *\n * e.g. const mixin = css`...` -> \"mixin\"\n */\nconst getStyledComponentName = (\n  taggedTemplateExpressionPath: NodePath<babelTypes.TaggedTemplateExpression>\n) => {\n  const variableDeclaratorPath = taggedTemplateExpressionPath.findParent(\n    (path) => path.isVariableDeclarator()\n  );\n  if (\n    !variableDeclaratorPath ||\n    !(\"id\" in variableDeclaratorPath.node) ||\n    variableDeclaratorPath.node.id?.type !== \"Identifier\"\n  ) {\n    return null;\n  }\n  return variableDeclaratorPath.node.id.name;\n};\n\n/**\n * Try to get the name of a member expression\n *\n * e.g. props.disabled -> \"propsDisabled\"\n * e.g. props.user.disabled -> \"propsUserDisabled\n */\nfunction getMemberExpressionName(node: babelTypes.MemberExpression): string {\n  if (\n    !node.object ||\n    !node.property ||\n    (node.object.type !== \"Identifier\" &&\n      node.object.type !== \"MemberExpression\")\n  ) {\n    return \"\";\n  }\n  const objectName =\n    node.object.type === \"Identifier\"\n      ? node.object.name\n      : getMemberExpressionName(node.object);\n  const property = node.property;\n  let propertyName = \"\";\n  if (property.type === \"Identifier\") {\n    propertyName = property.name;\n  } else if (property.type === \"StringLiteral\") {\n    propertyName = property.value;\n  }\n  if (!propertyName) {\n    return \"\";\n  }\n  return objectName + propertyName[0].toUpperCase() + propertyName.slice(1);\n}\n\n/**\n * Try to get the name of a css literal\n *\n * e.g. ({$disabled}) => $disabled && css`...` -> \"is_$disabled\"\n */\nexport default function getCssName(\n  literal: NodePath<babelTypes.TaggedTemplateExpression>\n) {\n  const conditions = extractConditions(literal);\n  if (conditions.length === 0) {\n    const mixinName = getStyledComponentName(literal);\n    return mixinName ? mixinName : \"yak\";\n  }\n  return conditions.join(\"_\").replace(/\\$/g, \"\");\n}\n","/**\n * JS Implementation of MurmurHash2\n *\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n *\n * @param str ASCII only\n * @return Base 36 encoded hash result\n */\nexport default function murmurhash2_32_gc(str: string) {\n  let l = str.length;\n  let h = l;\n  let i = 0;\n  let k;\n\n  while (l >= 4) {\n    k =\n      (str.charCodeAt(i) & 0xff) |\n      ((str.charCodeAt(++i) & 0xff) << 8) |\n      ((str.charCodeAt(++i) & 0xff) << 16) |\n      ((str.charCodeAt(++i) & 0xff) << 24);\n\n    k =\n      (k & 0xffff) * 0x5bd1e995 + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16);\n    k ^= k >>> 24;\n    k =\n      (k & 0xffff) * 0x5bd1e995 + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16);\n\n    h =\n      ((h & 0xffff) * 0x5bd1e995 +\n        ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^\n      k;\n\n    l -= 4;\n    ++i;\n  } // forgive existing code\n\n  /* eslint-disable no-fallthrough */ switch (l) {\n    case 3:\n      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n    case 2:\n      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n    case 1:\n      h ^= str.charCodeAt(i) & 0xff;\n      h =\n        (h & 0xffff) * 0x5bd1e995 +\n        ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16);\n  }\n  /* eslint-enable no-fallthrough */\n\n  h ^= h >>> 13;\n  h = (h & 0xffff) * 0x5bd1e995 + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16);\n  h ^= h >>> 15;\n\n  return (h >>> 0).toString(36);\n}\n","import type { NodePath, types as babelTypes } from \"@babel/core\";\n\n/**\n * Returns the name of the expression\n */\nexport const getConstantName = (\n  expression: babelTypes.Expression,\n  t: typeof babelTypes\n) => {\n  // e.g. styled.div`color: ${x};`\n  if (t.isIdentifier(expression)) {\n    // e.g. x\n    return expression.name;\n  } else if (\n    t.isMemberExpression(expression) &&\n    t.isIdentifier(expression.object)\n  ) {\n    // e.g. x for x.y\n    return expression.object.name;\n  } else if (\n    t.isCallExpression(expression) &&\n    t.isIdentifier(expression.callee)\n  ) {\n    // e.g. x for x()\n    return expression.callee.name;\n  } else if (\n    t.isCallExpression(expression) &&\n    t.isMemberExpression(expression.callee) &&\n    t.isIdentifier(expression.callee.object)\n  ) {\n    // e.g. x for x.y()\n    return expression.callee.object.name;\n  } else {\n    return null;\n  }\n};\n\n/**\n * Extracts all top level constant values from a program path\n */\nexport function getConstantValues(\n  path: NodePath<babelTypes.Program>,\n  t: typeof babelTypes\n) {\n  const topLevelConstBindings = new Map<string, string | number | null>();\n  const bindings = Object.entries(path.scope.bindings);\n  for (const [name, binding] of bindings) {\n    if (binding.kind === \"module\") {\n      topLevelConstBindings.set(name, null);\n      continue;\n    }\n    if (\n      binding.kind === \"let\" ||\n      binding.kind === \"var\" ||\n      binding.kind === \"const\"\n    ) {\n      // don't consider function declarations or arrow functions as constants\n      if (\n        !(\"init\" in binding.path.node) ||\n        t.isFunctionDeclaration(binding.path.node.init) ||\n        t.isArrowFunctionExpression(binding.path.node.init)\n      ) {\n        topLevelConstBindings.set(name, null);\n        continue;\n      }\n      const value = binding.path.node.init;\n      topLevelConstBindings.set(\n        name,\n        t.isStringLiteral(value) || t.isNumericLiteral(value)\n          ? value.value\n          : null\n      );\n    }\n  }\n  return topLevelConstBindings;\n}\n"],"mappings":"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","names":["getStyledComponentName","variableName"]}