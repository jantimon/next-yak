{"version":3,"sources":["../index.ts","../rules/cssNestingOperator.ts","../utils.ts","../rules/utils.ts","../rules/enforceSemicolon.ts","../rules/styleConditions.ts"],"sourcesContent":["import fs from \"node:fs\";\nimport { cssNestingOperator } from \"./rules/cssNestingOperator.js\";\nimport { enforceSemicolons } from \"./rules/enforceSemicolon.js\";\nimport { styleConditions } from \"./rules/styleConditions.js\";\n\nconst pkg = JSON.parse(\n  fs.readFileSync(new URL(\"./package.json\", import.meta.url), \"utf8\"),\n);\n\nconst plugin = {\n  meta: {\n    name: pkg.name,\n    version: pkg.version,\n  },\n  configs: {},\n  rules: {\n    \"css-nesting-operator\": cssNestingOperator,\n    \"enforce-semicolon\": enforceSemicolons,\n    \"style-conditions\": styleConditions,\n  },\n  processors: {},\n};\n\nObject.assign(plugin.configs, {\n  recommended: {\n    plugins: {\n      [pkg.name]: plugin,\n    },\n    rules: {\n      [`${pkg.name}/css-nesting-operator`]: \"error\",\n      [`${pkg.name}/enforce-semicolon`]: \"error\",\n      [`${pkg.name}/style-conditions`]: \"suggestion\",\n    },\n  },\n});\n\nexport default plugin;\n","import { AST_NODE_TYPES, TSESTree } from \"@typescript-eslint/utils\";\nimport type { RuleFixer } from \"@typescript-eslint/utils/ts-eslint\";\nimport { createRule } from \"../utils.js\";\nimport { importsNextYak, isStyledOrCssTag } from \"./utils.js\";\n\nexport const cssNestingOperator = createRule({\n  name: \"css-nesting-operator\",\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Enforces css selectors in next-yak to correctly use the nesting selector (&)\",\n    },\n    messages: {\n      missingNestingOperator:\n        \"Nesting selector missing.\\nDid you forget the &?\",\n    },\n    // fixable: \"code\",\n    hasSuggestions: true,\n    schema: [],\n  },\n  defaultOptions: [],\n  create: (context) => {\n    const { importedNames, ImportDeclaration } = importsNextYak();\n    return {\n      ImportDeclaration,\n      /** All return statements in styled/css literals */\n      TaggedTemplateExpression(node: TSESTree.TaggedTemplateExpression) {\n        if (\n          importedNames.styled === undefined &&\n          importedNames.css === undefined\n        ) {\n          return;\n        }\n\n        const templateLiteral = node.quasi;\n\n        if (\n          !templateLiteral ||\n          templateLiteral.type !== AST_NODE_TYPES.TemplateLiteral ||\n          // No next-yak imports\n          (importedNames.styled === undefined &&\n            importedNames.css === undefined) ||\n          // Not a styled or css tag\n          !isStyledOrCssTag(node, importedNames) ||\n          // As we check the full code of a template literal (including nested literals),\n          // Don't check nested template literals as we check the full content of a template literal.\n          hasParentTaggedTemplateExpression(node)\n        ) {\n          return;\n        }\n\n        // Returns the raw code of the template literal `...`\n        const codeRaw = context.sourceCode.getText(templateLiteral);\n        if (!codeRaw) {\n          return;\n        }\n\n        // Replace all content inside parentheses with underscores to avoid matching unrelated selectors\n        // e.g. :not(:disabled, :active):focused -> :not(_______):focused\n        // https://regex101.com/r/ik69ze/1\n        const code = codeRaw.replace(\n          /\\(([^()]+)\\)/g,\n          (_match, capturedGroup) => {\n            const underscoreReplacement = \"_\".repeat(capturedGroup.length);\n            return `(${underscoreReplacement})`;\n          },\n        );\n\n        // Regex to find all possible elements to check\n        // https://regex101.com/r/nNIxaX/1\n        // Group 0: The full match\n        // Group 1: The selector\n        const possibleElements =\n          /(?<=[,\\n])[^:,\\n\\S]*(?:^|\\s)((?:>|\\+|~)|:[^\\s,{]+)[^,{\\n]*(?=[,{])/gm;\n\n        let match;\n        while ((match = possibleElements.exec(code)) !== null) {\n          // If & operator is already present -> ok\n          // Do we need to check for whitespaces around it?\n          if (match[0].includes(\"&\")) {\n            continue;\n          }\n\n          // False positives -> ok\n          if (\n            match[1] === \":root\" ||\n            match[1].startsWith(\":global(\") ||\n            match[1] === \":modal\"\n          ) {\n            continue;\n          }\n\n          // Nested selectors already have a reference -> ok\n          if (isNestedSelector(code, match)) {\n            continue;\n          }\n\n          // Check if element is first in match so we can provide a fix\n          const elementIsFirstInMatch = match[0].trim().startsWith(match[1]);\n\n          let fixFn = undefined;\n          if (elementIsFirstInMatch) {\n            const selectorStartIndex =\n              templateLiteral.range[0] +\n              match.index +\n              match[0].indexOf(match[1]);\n\n            let fixSnippet = \"&\";\n            if (match[1] === \">\" || match[1] === \"+\" || match[1] === \"~\") {\n              fixSnippet = \"& \";\n            }\n\n            fixFn = (fixer: RuleFixer) =>\n              fixer.insertTextBeforeRange(\n                // End location doesn't matter, just take +1 of the start location\n                [selectorStartIndex, selectorStartIndex + 1],\n                fixSnippet,\n              );\n          }\n\n          // Get the location of the trimmed match in the code for highlighting in the IDE\n          const matchTrimmed = match[0].trim();\n          const loc = mapRegexMatchToLoc(code, match, matchTrimmed);\n\n          context.report({\n            node: templateLiteral,\n            messageId: \"missingNestingOperator\",\n\n            // The location within the template literal needs to be adjusted to the location in the file\n            loc: {\n              start: {\n                line: templateLiteral.loc.start.line + loc.start.line - 1,\n                // If on first line, add start column of templateLiteral. Not possible with prettier.\n                column: loc.start.column,\n              },\n              end: {\n                line: templateLiteral.loc.start.line + loc.end.line - 1,\n                // If on first line, add start column of templateLiteral. Not possible with prettier.\n                column: loc.end.column,\n              },\n            },\n\n            // If a fix is possible, suggest it\n            suggest: fixFn && [\n              {\n                messageId: \"missingNestingOperator\",\n                fix: fixFn,\n              },\n            ],\n          });\n        }\n      },\n    };\n  },\n});\n\n/**\n * Checks, if the parent expression is a tagged template expression, up to maxLevels up.\n */\nfunction hasParentTaggedTemplateExpression(node: TSESTree.Node, maxLevels = 5) {\n  let currentLevel = 1;\n  let currentNode: TSESTree.Node | undefined = node.parent;\n\n  while (currentNode && currentLevel < maxLevels) {\n    if (currentNode.type === AST_NODE_TYPES.TaggedTemplateExpression) {\n      return true;\n    }\n\n    currentNode = currentNode.parent;\n    currentLevel++;\n  }\n\n  return false;\n}\n\n/**\n * Checks if a character is a valid identifier character.\n */\nfunction isValidIdentifierChar(char: string) {\n  const identifierRegex = /^[a-zA-Z_$]+$/;\n  return identifierRegex.test(char);\n}\n\n/**\n * Checks if a selector is nested in a selector, taking into account comments and nested template literals.\n *\n * It also has a basic check for expressions containing simple identifiers used for selectors\n * e.g. ${Selector} {} -> valid nesting, ${myQuery.mobile} {} -> not valid nesting\n */\nfunction isNestedSelector(sourceCode: string, regexMatch: RegExpMatchArray) {\n  if (regexMatch.index === undefined) {\n    return false;\n  }\n\n  const groupStartIndex = regexMatch.index;\n\n  let nestingLevel = 0;\n\n  // State is true if any relevant nesting is detected\n  const nestingLevelState: boolean[] = [false];\n  let inComment = false;\n\n  let withinExpressionOnSameLine = false;\n  let invalidExpressionSelectorOnSameLine = false;\n\n  for (let i = 0; i < sourceCode.length; i++) {\n    const char = sourceCode[i];\n\n    if (i === groupStartIndex) {\n      return nestingLevelState.some((state) => state);\n    }\n\n    // Detect comments\n    if (char === \"/\" && sourceCode[i + 1] === \"*\") {\n      inComment = true;\n    } else if (char === \"*\" && sourceCode[i + 1] === \"/\") {\n      inComment = false;\n    }\n\n    if (!inComment) {\n      // Detect nested expressions\n      if (char === \"{\") {\n        if (sourceCode[i - 1] === \"$\") {\n          // Expressions do not count as nesting\n          nestingLevelState[++nestingLevel] = false;\n          withinExpressionOnSameLine = true;\n        } else {\n          nestingLevelState[++nestingLevel] =\n            !invalidExpressionSelectorOnSameLine;\n        }\n      } else if (char === \"}\") {\n        nestingLevelState.pop();\n        withinExpressionOnSameLine = false;\n      } else if (char === \"\\n\") {\n        withinExpressionOnSameLine = false;\n        invalidExpressionSelectorOnSameLine = false;\n      } else {\n        if (withinExpressionOnSameLine) {\n          if (!isValidIdentifierChar(char)) {\n            invalidExpressionSelectorOnSameLine = true;\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Maps a regex match to a location in the provided source code.\n */\nfunction mapRegexMatchToLoc(\n  sourceCode: string,\n  regexMatch: RegExpMatchArray,\n  matchText: string,\n) {\n  let line = 1;\n  let column = 0;\n\n  const loc = {\n    start: { line, column },\n    end: { line, column },\n  };\n\n  if (regexMatch.index === undefined) {\n    return loc;\n  }\n\n  const groupStartIndex =\n    regexMatch.index + Math.max(regexMatch[0].indexOf(matchText), 0);\n  const groupEndIndex = groupStartIndex + matchText.length;\n\n  for (let i = 0; i < sourceCode.length; i++) {\n    const char = sourceCode[i];\n\n    if (i === groupStartIndex) {\n      loc.start = { line, column };\n    }\n\n    if (i === groupEndIndex) {\n      loc.end = { line, column };\n    }\n\n    if (char === \"\\n\") {\n      line++;\n      column = 0;\n    } else {\n      column++;\n    }\n  }\n\n  return loc;\n}\n","import { ESLintUtils } from \"@typescript-eslint/utils\";\n\nexport interface EsLintPluginYakRuleDocs {\n  description: string;\n  recommended?: boolean;\n  requiresTypeChecking?: boolean;\n}\n\nexport const createRule = ESLintUtils.RuleCreator<EsLintPluginYakRuleDocs>(\n  (name) =>\n    `https://github.com/DigitecGalaxus/next-yak/packages/eslint-plugin/docs/${name}.md`,\n);\n","import { AST_NODE_TYPES, TSESTree } from \"@typescript-eslint/utils\";\n\nexport const importsNextYak = () => {\n  /** track the imported names for css and styled from next-yak */\n  const importedNames: ImportedNames = {};\n\n  return {\n    importedNames,\n    ImportDeclaration(node: TSESTree.ImportDeclaration) {\n      if (node.source.value === \"next-yak\") {\n        node.specifiers.forEach((specifier) => {\n          if (\n            specifier.type === AST_NODE_TYPES.ImportSpecifier &&\n            specifier.imported.type === AST_NODE_TYPES.Identifier\n          ) {\n            if (specifier.imported.name === \"styled\") {\n              importedNames.styled = specifier.local.name;\n            } else if (specifier.imported.name === \"css\") {\n              importedNames.css = specifier.local.name;\n            }\n          }\n        });\n      }\n    },\n  };\n};\n\nexport type ImportedNames = {\n  styled?: string;\n  css?: string;\n};\n\nexport function isStyledOrCssTag(\n  node: TSESTree.Node,\n  importedNames: ImportedNames,\n): false | \"styled\" | \"css\" {\n  if (node.type !== AST_NODE_TYPES.TaggedTemplateExpression) {\n    return false;\n  }\n  const { tag } = node;\n\n  // Check for simple styled`` or css``\n  if (\n    tag.type === AST_NODE_TYPES.Identifier &&\n    (tag.name === importedNames.styled || tag.name === importedNames.css)\n  ) {\n    return \"css\";\n  }\n  // Check for styled.button`` or styled(Component)``\n  if (tag.type === AST_NODE_TYPES.MemberExpression) {\n    return tag.object.type === AST_NODE_TYPES.Identifier &&\n      tag.object.name === importedNames.styled\n      ? (\"styled\" as const)\n      : false;\n  }\n  // Check for styled(button)`` or styled(button).attrs()`` or styled.div.attrs()``\n  if (tag.type === AST_NODE_TYPES.CallExpression) {\n    // Check for attrs() method\n    if (tag.callee.type === AST_NODE_TYPES.MemberExpression) {\n      const callee = tag.callee as TSESTree.MemberExpression;\n      if (\n        callee.property.type === AST_NODE_TYPES.Identifier &&\n        callee.property.name === \"attrs\"\n      ) {\n        const memberExpression = callee.property\n          .parent as TSESTree.MemberExpression;\n\n        // styled(button).attrs()\n        if (memberExpression.object.type === AST_NODE_TYPES.CallExpression) {\n          const callExpression =\n            memberExpression.object as TSESTree.CallExpression;\n\n          return callExpression.callee.type === AST_NODE_TYPES.Identifier &&\n            callExpression.callee.name === importedNames.styled\n            ? \"styled\"\n            : false;\n        }\n        // styled.button.attrs()\n        else if (\n          memberExpression.object.type === AST_NODE_TYPES.MemberExpression\n        ) {\n          const memberExpressionObject =\n            memberExpression.object as TSESTree.MemberExpression;\n          return memberExpressionObject.object.type ===\n            AST_NODE_TYPES.Identifier &&\n            memberExpressionObject.object.name === importedNames.styled\n            ? \"styled\"\n            : false;\n        }\n      }\n    }\n\n    // Check for styled()\n    return tag.callee.type === AST_NODE_TYPES.Identifier &&\n      tag.callee.name === importedNames.styled\n      ? \"styled\"\n      : false;\n  }\n\n  return false;\n}\n","import { AST_NODE_TYPES, TSESTree } from \"@typescript-eslint/utils\";\nimport { createRule } from \"../utils.js\";\nimport { importsNextYak, isStyledOrCssTag } from \"./utils.js\";\n\nexport const enforceSemicolons = createRule({\n  name: \"enforce-semicolons\",\n  meta: {\n    type: \"problem\",\n    docs: {\n      description:\n        \"Enforces that expression in styled/css literals from next-yak use semicolons\",\n    },\n    messages: {\n      lonelyExpression:\n        \"Expressions must have a selector, an opening bracket or semicolon in the same line\\nDid you forget a semicolon?\",\n    },\n    fixable: \"code\",\n    schema: [],\n  },\n  defaultOptions: [],\n  create: (context) => {\n    const { importedNames, ImportDeclaration } = importsNextYak();\n    return {\n      ImportDeclaration,\n      TaggedTemplateExpression(node: TSESTree.TaggedTemplateExpression) {\n        if (\n          importedNames.styled === undefined &&\n          importedNames.css === undefined\n        ) {\n          return;\n        }\n\n        const templateLiteral = node.quasi;\n        if (!templateLiteral || !isStyledOrCssTag(node, importedNames)) {\n          return;\n        }\n\n        if (templateLiteral.type !== AST_NODE_TYPES.TemplateLiteral) {\n          throw new Error(\"Unexpected AST - bug in yakEnforceSemicolons\");\n        }\n\n        // Look for all identifier expression inside the template e.g. ${foo} or ${foo.bar}\n        templateLiteral.expressions.forEach((expression, index) => {\n          if (\n            expression.type !== AST_NODE_TYPES.Identifier &&\n            expression.type !== AST_NODE_TYPES.MemberExpression\n          ) {\n            return;\n          }\n\n          const codeBefore = getQuasiValue(templateLiteral.quasis[index]);\n          const codeAfter = getQuasiValue(templateLiteral.quasis[index + 1]);\n\n          const codeBeforeIsWhitespaceOnly = !codeBefore.trim();\n          const isFirstExpression = codeBeforeIsWhitespaceOnly && index === 0;\n          const isAloneInLine =\n            (isFirstExpression || codeBefore.match(/\\n\\s*$/)) &&\n            (!codeAfter || codeAfter.match(/^\\s*\\n/));\n\n          // A Mixin is always alone in a line.\n          if (!isAloneInLine) {\n            return;\n          }\n\n          const previousExpressionType =\n            templateLiteral.expressions[index - 1]?.type;\n          const previousExpressionIsTerminating =\n            previousExpressionType === AST_NODE_TYPES.ArrowFunctionExpression ||\n            previousExpressionType === AST_NODE_TYPES.ConditionalExpression ||\n            previousExpressionType === AST_NODE_TYPES.LogicalExpression;\n\n          // check if the code before ends with a semicolon or a bracket or is an arrow function\n          if (\n            isFirstExpression ||\n            (previousExpressionIsTerminating && codeBeforeIsWhitespaceOnly) ||\n            codeBefore.match(/[;{}]\\s*$/)\n          ) {\n            context.report({\n              node: expression,\n              messageId: \"lonelyExpression\",\n              fix: (fixer) => {\n                return fixer.insertTextAfterRange(\n                  [expression.range[0], expression.range[1] + 1],\n                  \";\",\n                );\n              },\n            });\n          }\n        });\n      },\n    };\n  },\n});\n\nfunction getQuasiValue(quasi: TSESTree.TemplateElement | undefined) {\n  if (!quasi) {\n    return \"\";\n  }\n  return quasi.value.cooked;\n}\n","import { AST_NODE_TYPES, TSESTree } from \"@typescript-eslint/utils\";\nimport { createRule } from \"../utils.js\";\nimport { importsNextYak, isStyledOrCssTag } from \"./utils.js\";\n\ntype ImportedNames = {\n  styled?: string;\n  css?: string;\n};\n\nexport const styleConditions = createRule({\n  name: \"style-conditions\",\n  meta: {\n    type: \"suggestion\",\n    docs: {\n      description:\n        \"Enforces that arrow functions only return runtime values or css literals in styled/css literals from next-yak\",\n      recommended: true,\n      requiresTypeChecking: true,\n    },\n    messages: {\n      invalidRuntimeReturnValue:\n        \"When possible arrow functions in styled/css literals from next-yak should return css literals (css`...`) instead of inline values. CSS literals create a CSS class, which is better for performance.\",\n      invalidCssReturnValue:\n        \"CSS literals can not be converted into a css variable - try to move the css property also into the arrow function or remove the css``\",\n    },\n    schema: [],\n  },\n  defaultOptions: [],\n  create: (context) => {\n    const { importedNames, ImportDeclaration } = importsNextYak();\n    return {\n      ImportDeclaration,\n      TaggedTemplateExpression(node: TSESTree.TaggedTemplateExpression) {\n        if (\n          importedNames.styled === undefined &&\n          importedNames.css === undefined\n        ) {\n          return;\n        }\n\n        if (!node.parent || isStyledOrCssTag(node, importedNames) !== \"css\") {\n          return;\n        }\n        const { tag, needle } = findClosestStyledOrCssTag(\n          node.parent,\n          importedNames,\n        );\n        if (!tag) {\n          return;\n        }\n\n        const index = tag.quasi.expressions.findIndex(\n          (expr) => expr === needle,\n        );\n        if (index === -1) {\n          return;\n        }\n\n        const codeBefore = tag.quasi.quasis[index].value.raw;\n        // Guess that if a quasi ends with a colon that it is a declaration e.g.\n        // css`color: ${({ color }) => color}`\n        const isDeclaration = codeBefore.trim().endsWith(\":\");\n        if (!isDeclaration) {\n          return;\n        }\n\n        context.report({\n          node,\n          messageId: \"invalidCssReturnValue\",\n        });\n      },\n\n      /** All return statements in styled/css literals */\n      \"TaggedTemplateExpression :matches(ArrowFunctionExpression, ReturnStatement)\"(\n        node: TSESTree.ReturnStatement | TSESTree.ArrowFunctionExpression,\n      ) {\n        // Params are used to detect valid runtime values\n        // e.g. css`width: ${({ $size }) => $size}px`\n        const { tag, params } = findClosestStyledOrCssTag(node, importedNames);\n        if (!tag) {\n          return;\n        }\n\n        // Get the return value of the arrow function or the return statement\n        // e.g. `() => 42` or () => { return 42 }`\n        const returnValue =\n          node.type === AST_NODE_TYPES.ReturnStatement\n            ? node.argument\n            : node.body.type !== AST_NODE_TYPES.BlockStatement\n            ? node.body\n            : undefined;\n\n        if (\n          returnValue &&\n          !isNodeAccessingParams(returnValue, params, importedNames)\n        ) {\n          context.report({\n            node: returnValue,\n            messageId: \"invalidRuntimeReturnValue\",\n          });\n        }\n      },\n    };\n  },\n});\n\n/**\n * Searches the node and its parents for the first css``, styled.sth`` or styled(Component)``\n */\nfunction findClosestStyledOrCssTag(\n  node: TSESTree.Node,\n  importedNames: ImportedNames,\n):\n  | {\n      tag: undefined;\n      type: undefined;\n      needle: TSESTree.Node;\n      params: TSESTree.Parameter[];\n    }\n  | {\n      tag: TSESTree.TaggedTemplateExpression;\n      type: \"css\" | \"styled\";\n      needle: TSESTree.Node;\n      params: TSESTree.Parameter[];\n    } {\n  let current: TSESTree.Node | undefined = node;\n  let params: TSESTree.Parameter[] = [];\n  let needle: TSESTree.Node = node;\n\n  while (current) {\n    if (current.type === AST_NODE_TYPES.ArrowFunctionExpression) {\n      params = current.params;\n    } else {\n      const type = isStyledOrCssTag(current, importedNames);\n      if (type && current.type === AST_NODE_TYPES.TaggedTemplateExpression) {\n        return { tag: current, needle, params, type };\n      }\n    }\n    if (current.type !== AST_NODE_TYPES.TemplateLiteral) {\n      needle = current;\n    }\n    current = current.parent;\n  }\n\n  return { tag: undefined, needle, type: undefined, params };\n}\n\n/**\n * Verifies that node is a css literal from the given imported names\n *\n * e.g. css`color: red`\n */\nfunction isCssLiteral(\n  node: TSESTree.Node,\n  importedNames: ImportedNames,\n): boolean {\n  return (\n    node.type === AST_NODE_TYPES.TaggedTemplateExpression &&\n    node.tag.type === AST_NODE_TYPES.Identifier &&\n    node.tag.name === importedNames.css\n  );\n}\n\n/**\n * Verifies that node is a valid identifier from the given params\n * Either a identifier or a member expression.\n *\n * In this example foo and foo.bar are valid:\n * `(foo) => foo.bar` or `(foo) => foo`\n */\nfunction isValidIdentifier(\n  node: TSESTree.Node,\n  params: TSESTree.Parameter[],\n): boolean {\n  if (node.type === AST_NODE_TYPES.Identifier) {\n    return params.some((param) => {\n      if (param.type === AST_NODE_TYPES.Identifier) {\n        return param.name === node.name;\n      }\n      if (param.type === AST_NODE_TYPES.ObjectPattern) {\n        return param.properties.some(\n          (prop) =>\n            prop.type === AST_NODE_TYPES.Property &&\n            prop.key.type === AST_NODE_TYPES.Identifier &&\n            prop.key.name === node.name,\n        );\n      }\n      return false;\n    });\n  }\n  if (node.type === AST_NODE_TYPES.MemberExpression) {\n    return isValidIdentifier(node.object, params);\n  }\n  return false;\n}\n\nfunction isFalsyLiteral(node: TSESTree.Node): boolean {\n  return (\n    (node.type === AST_NODE_TYPES.Literal &&\n      (node.value === null ||\n        node.value === false ||\n        node.value === 0 ||\n        node.value === \"\")) ||\n    (node.type === AST_NODE_TYPES.Identifier &&\n      (node.name === \"undefined\" || node.name === \"null\"))\n  );\n}\n\n/**\n * Verifies that the expression uses a value fro the params\n */\nfunction isNodeAccessingParams(\n  node: TSESTree.Node,\n  params: TSESTree.Parameter[],\n  importedNames: ImportedNames,\n): boolean {\n  switch (node.type) {\n    case AST_NODE_TYPES.Literal:\n      // A literal is not a runtime value\n      return false;\n    case AST_NODE_TYPES.TemplateLiteral:\n      // If at least one expression uses a runtime value, the whole template literal is valid\n      return (\n        node.expressions.length > 0 &&\n        node.expressions.some((expr) =>\n          isNodeAccessingParams(expr, params, importedNames),\n        )\n      );\n    case AST_NODE_TYPES.Identifier:\n      // An identifier is valid if it's a parameter\n      return isValidIdentifier(node, params);\n    case AST_NODE_TYPES.MemberExpression:\n      //\n      return isValidIdentifier(node, params);\n    case AST_NODE_TYPES.TaggedTemplateExpression:\n      return isCssLiteral(node, importedNames);\n    case AST_NODE_TYPES.LogicalExpression:\n      // logical operators are valid if the left side is a valid test expression\n      // e.g.: isLarge($size) && css`width: 100px`\n      if (node.operator === \"&&\" && isValidTestExpression(node.left)) {\n        return isNodeAccessingParams(node.right, params, importedNames);\n      }\n      // && and || are valid if both sides are valid\n      return (\n        isNodeAccessingParams(node.left, params, importedNames) &&\n        isNodeAccessingParams(node.right, params, importedNames)\n      );\n    case AST_NODE_TYPES.ConditionalExpression:\n      return (\n        isValidTestExpression(node.test) &&\n        (isNodeAccessingParams(node.consequent, params, importedNames) ||\n          isNodeAccessingParams(node.alternate, params, importedNames))\n      );\n    case AST_NODE_TYPES.BinaryExpression:\n      // Other binary expressions like +, -, etc. are valid if at least one side is a runtime value\n      return (\n        isNodeAccessingParams(node.left, params, importedNames) ||\n        isNodeAccessingParams(node.right, params, importedNames)\n      );\n    case AST_NODE_TYPES.UnaryExpression:\n      // Handle unary expressions with the logical NOT operator\n      if (node.operator === \"!\") {\n        return isNodeAccessingParams(node.argument, params, importedNames);\n      }\n      return false;\n    default:\n      return isFalsyLiteral(node);\n  }\n}\n\n/**\n * Expressions that can be used as test expressions in logical operators or conditionals\n */\nfunction isValidTestExpression(node: TSESTree.Node): boolean {\n  switch (node.type) {\n    // true or false\n    case AST_NODE_TYPES.Literal:\n      return node.value === true || node.value === false;\n    // x\n    case AST_NODE_TYPES.Identifier:\n      return true;\n    // x.isLarge\n    case AST_NODE_TYPES.MemberExpression:\n      return true;\n    // !x\n    case AST_NODE_TYPES.UnaryExpression:\n      return true;\n    // test(x)\n    case AST_NODE_TYPES.CallExpression:\n      return true;\n    // x === 4\n    case AST_NODE_TYPES.LogicalExpression:\n      return true;\n    // x > 4\n    case AST_NODE_TYPES.BinaryExpression:\n      return true;\n    default:\n      return false;\n  }\n}\n"],"mappings":"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","names":["AST_NODE_TYPES","AST_NODE_TYPES","AST_NODE_TYPES","AST_NODE_TYPES","AST_NODE_TYPES","AST_NODE_TYPES"]}